<!DOCTYPE html>

<html>
<head>
  <title>bricks.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="advancedToolbar.html">
                advancedToolbar.js
              </a>
            
              
              <a class="source" href="basemapSelector.html">
                basemapSelector.js
              </a>
            
              
              <a class="source" href="bookmarkLink.html">
                bookmarkLink.js
              </a>
            
              
              <a class="source" href="dataLoader.html">
                dataLoader.js
              </a>
            
              
              <a class="source" href="dataLoaderGui.html">
                dataLoaderGui.js
              </a>
            
              
              <a class="source" href="datagrid.html">
                datagrid.js
              </a>
            
              
              <a class="source" href="datagridClickHandler.html">
                datagridClickHandler.js
              </a>
            
              
              <a class="source" href="eventManager.html">
                eventManager.js
              </a>
            
              
              <a class="source" href="featureClickHandler.html">
                featureClickHandler.js
              </a>
            
              
              <a class="source" href="featureHighlighter.html">
                featureHighlighter.js
              </a>
            
              
              <a class="source" href="filterManager.html">
                filterManager.js
              </a>
            
              
              <a class="source" href="geoSearch.html">
                geoSearch.js
              </a>
            
              
              <a class="source" href="globalStorage.html">
                globalStorage.js
              </a>
            
              
              <a class="source" href="graphicExtension.html">
                graphicExtension.js
              </a>
            
              
              <a class="source" href="gui.html">
                gui.js
              </a>
            
              
              <a class="source" href="imageExport.html">
                imageExport.js
              </a>
            
              
              <a class="source" href="layerGroup.html">
                layerGroup.js
              </a>
            
              
              <a class="source" href="layerItem.html">
                layerItem.js
              </a>
            
              
              <a class="source" href="layerLoader.html">
                layerLoader.js
              </a>
            
              
              <a class="source" href="map.html">
                map.js
              </a>
            
              
              <a class="source" href="mapClickHandler.html">
                mapClickHandler.js
              </a>
            
              
              <a class="source" href="maptips.html">
                maptips.js
              </a>
            
              
              <a class="source" href="navigation.html">
                navigation.js
              </a>
            
              
              <a class="source" href="quickzoom.html">
                quickzoom.js
              </a>
            
              
              <a class="source" href="ramp.html">
                ramp.js
              </a>
            
              
              <a class="source" href="stepItem.html">
                stepItem.js
              </a>
            
              
              <a class="source" href="theme.html">
                theme.js
              </a>
            
              
              <a class="source" href="RAMP-starter.html">
                RAMP-starter.js
              </a>
            
              
              <a class="source" href="areaTool.html">
                areaTool.js
              </a>
            
              
              <a class="source" href="baseTool.html">
                baseTool.js
              </a>
            
              
              <a class="source" href="bufferTool.html">
                bufferTool.js
              </a>
            
              
              <a class="source" href="distanceTool.html">
                distanceTool.js
              </a>
            
              
              <a class="source" href="populationTool.html">
                populationTool.js
              </a>
            
              
              <a class="source" href="array.html">
                array.js
              </a>
            
              
              <a class="source" href="bricks.html">
                bricks.js
              </a>
            
              
              <a class="source" href="checkbox.html">
                checkbox.js
              </a>
            
              
              <a class="source" href="checkboxGroup.html">
                checkboxGroup.js
              </a>
            
              
              <a class="source" href="decorator.html">
                decorator.js
              </a>
            
              
              <a class="source" href="dictionary.html">
                dictionary.js
              </a>
            
              
              <a class="source" href="functionMangler.html">
                functionMangler.js
              </a>
            
              
              <a class="source" href="popupManager.html">
                popupManager.js
              </a>
            
              
              <a class="source" href="prototype.html">
                prototype.js
              </a>
            
              
              <a class="source" href="tmplHelper.html">
                tmplHelper.js
              </a>
            
              
              <a class="source" href="tmplUtil.html">
                tmplUtil.js
              </a>
            
              
              <a class="source" href="url.html">
                url.js
              </a>
            
              
              <a class="source" href="util.html">
                util.js
              </a>
            
              
              <a class="source" href="bootstrapper.html">
                bootstrapper.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>bricks.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>﻿<span class="hljs-comment">/*global console, define, $, jscolor, RColor, Base */</span>

<span class="hljs-comment">/** 
* Bricks is a static collection of form controls rolled into prototypical objects with extra functions available. The main purpose is to use them in the choice tree for adding datasets but they can be reused anywhere where form controls are required.
* @module Utils
* @submodule Bricks
*/</span>

<span class="hljs-comment">/**
* Bricks is a static collection of form controls rolled into prototypical objects with extra functions available. The main purpose is to use them in the choice tree for adding datasets but they can be reused anywhere where form controls are required.
*
* 
* ####Imports RAMP Modules:
* {{#crossLink "Util"}}{{/crossLink}}  
* {{#crossLink "TmplHelper"}}{{/crossLink}}  
* {{#crossLink "Array"}}{{/crossLink}}  
* {{#crossLink "Dictionary"}}{{/crossLink}}  
*  
* ####Uses RAMP Templates:
* {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
* 
* 
* @class Bricks
* @static
* @uses dojo/_base/lang
* 
*/</span>
define([
    <span class="hljs-comment">/* Dojo */</span>
    <span class="hljs-string">"dojo/_base/lang"</span>,

    <span class="hljs-comment">/* Text */</span>
    <span class="hljs-string">"dojo/text!./templates/bricks_template.json"</span>,

    <span class="hljs-comment">/* Util */</span>
    <span class="hljs-string">"utils/util"</span>, <span class="hljs-string">"utils/tmplHelper"</span>, <span class="hljs-string">"utils/array"</span>, <span class="hljs-string">"utils/dictionary"</span>
],
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lang,

        bricks_template,

        UtilMisc, TmplHelper, UtilArray, UtilDict)</span> </span>{
<span class="hljs-pi">        "use strict"</span>;

        <span class="hljs-keyword">var</span> Brick,

            ButtonBrick,
            OkCancelButtonBrick,

            MultiBrick,

            ChoiceBrick,

            DropDownBrick,
            ColorPickerBrick,
            SimpleInputBrick,
            FileInputBrick,

            templates = <span class="hljs-built_in">JSON</span>.parse(TmplHelper.stringifyTemplate(bricks_template));

        <span class="hljs-comment">/**
         * Generates a template node based on the name of the template and the data to be passed to the template engine. The set of brick templates is suppled to the {{#crossLink "TmplHelper"}}{{/crossLink}}   module.
         * 
         * @method template
         * @private
         * @param {String} key template name
         * @param {Object} data any data that should be passed to the template engine
         * @return {jObject} a generated template nodes
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">template</span><span class="hljs-params">(key, data)</span> </span>{
            <span class="hljs-comment">/*jshint validthis: true */</span>
            <span class="hljs-keyword">return</span> $(TmplHelper.template.call(<span class="hljs-keyword">this</span>, key, data, templates)); <span class="hljs-comment">// -&gt; No Strict violation!</span>
        }

        <span class="hljs-comment">/**
        * The basic Brick prototype with no special functions. A base from all other Bricks.
        * To instantiate, call {{#crossLink "Brick/new:method"}}{{/crossLink}} on the Brick prototype.
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class Brick
        * @constructor
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * 
        */</span>
        Brick = Base.extend({
            <span class="hljs-comment">/**
             * A Brick header.
             *
             * @property header
             * @for Brick
             * @private
             * @type {String}
             * @default ""
             */</span>

            <span class="hljs-comment">/**
             * A CSS class of the Brick container node.
             *
             * @property containerClass
             * @private
             * @type {String}
             * @default ""
             */</span>

            <span class="hljs-comment">/**
             * A name of the specific Brick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default ""
             */</span>

            <span class="hljs-comment">/**
             * An instructional text to be displayed.
             *
             * @property instructions
             * @private
             * @type {String}
             * @default ""
             */</span>

            <span class="hljs-comment">/**
             * A collection of rules specifying what external conditions must be valid for the Brick to be enabled.
             * This is not used directly by the Brick itself, but instead by the external object manipulating a collection of Bricks.
             * Two types of rules possible: "all" and "any". Any additional properties needed can be specified.
             * 
             * @property required
             * @type {Array}
             * @default null
             * @example
             *
             *      [
             *           {
             *               type: "all",
             *               check: ["serviceType", "serviceURL"]
             *           }
             *      ]
             */</span>

            <span class="hljs-comment">/**
             * A set of rules specifying states Brick should be frozen.
             *
             * @property freezeStates
             * @private
             * @type {Array}
             * @default []
             * @example
             *
             *      [
             *           Bricks.Brick.state.SUCCESS,
             *           Bricks.Brick.state.ERROR
             *       ],
             */</span>

            <span class="hljs-comment">/**
             * A default base template name.
             *
             * @property baseTemplate
             * @private
             * @type {String}
             * @default "default_base_template"
             */</span>

            <span class="hljs-comment">/**
             * A default notice template name.
             *
             * @property noticeTemplate
             * @private
             * @type {String}
             * @default "default_brick_notice"
             */</span>

            <span class="hljs-comment">/**
             * Indicates if the Brick is frozen and cannot be interacted with.
             *
             * @property _isFrozen
             * @private
             * @type {Boolean}
             * @default false
             */</span>

            <span class="hljs-comment">/**
             * A collection of listeners to be notified of specified Brick events.
             *
             * @property _listeners
             * @private
             * @type {Object}
             * @default {}
             */</span>

            <span class="hljs-comment">/**
             * A dictionary of possible Brick events.
             *
             * @property event
             * @type {Object}
             * @example
             *      event: {
             *          CHANGE: "brick/change"
             *      }
             * 
             */</span>
            event: {
                <span class="hljs-comment">/**
                * Published whenever a Brick undergoes some change.
                *
                * @event Bricks.Brick.event.CHANGE
                * @param data {Object} anything, usually result of calling getData() on the Brick
                */</span>
                CHANGE: <span class="hljs-string">"brick/change"</span>
            },

            <span class="hljs-comment">/**
             * A dictionary of Brick events.
             *
             * @property state
             * @type {Object}
             * @example
             *     state: {
             *       SUCCESS: "brick/success",
             *       ERROR: "brick/error",
             *       DEFAULT: "brick/default"
             *      }
             */</span>
            state: {
                SUCCESS: <span class="hljs-string">"brick/success"</span>,
                ERROR: <span class="hljs-string">"brick/error"</span>,
                DEFAULT: <span class="hljs-string">"brick/default"</span>
            },

            <span class="hljs-comment">/**
             * Initializes the Brick by generating a specified template and setting defaults.
             * 
             * @method new
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @retun Brick
             * @chainable
             * 
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        required: <span class="hljs-literal">null</span>,
                        freezeStates: [],
                        baseTemplate: <span class="hljs-string">"default_base_template"</span>,
                        noticeTemplate: <span class="hljs-string">"default_brick_notice"</span>
                    },
                    config,
                    {
                        id: id,
                        _isFrozen: <span class="hljs-literal">false</span>,
                        _listeners: {}
                    }
                );

                <span class="hljs-keyword">this</span>.node = template(<span class="hljs-keyword">this</span>.baseTemplate, <span class="hljs-keyword">this</span>);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        noticeNode: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">".brick-notice-placeholder"</span>)
                    }
                );

                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.required) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-keyword">this</span>.required)) {
                        <span class="hljs-keyword">this</span>.required.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req)</span> </span>{
                            req.type = req.type ? req.type : <span class="hljs-string">"all"</span>;
                        });
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">this</span>.required.type = <span class="hljs-keyword">this</span>.required.type ? <span class="hljs-keyword">this</span>.required.type : <span class="hljs-string">"all"</span>;
                    }
                }

            },

            <span class="hljs-comment">/**
             * Notifies a listener of a Brick event. 
             *
             * @method notify
             * @private
             * @param  {String} eventName an eventName that should be reported
             * @param  {Object} data      a payload object to be passed along with the @event
             * @return {Brick}           itself
             * @chainable
             */</span>
            notify: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(eventName, data)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;

                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._listeners[eventName]) {
                    <span class="hljs-keyword">this</span>._listeners[eventName] = [];
                }
                <span class="hljs-keyword">this</span>._listeners[eventName].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(listener)</span> </span>{
                    listener.call(that, data);
                });

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Sets a listener on the Brick for a specified eventName.
             *
             * @method on
             * @param  {String} eventName an eventName to listen for
             * @param  {Function} listener  a callback function to be called
             * @return {Brick}           itself
             * @chainable
             */</span>
            on: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(eventName, listener)</span> </span>{
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._listeners[eventName]) {
                    <span class="hljs-keyword">this</span>._listeners[eventName] = [];
                }
                <span class="hljs-keyword">this</span>._listeners[eventName].push(listener);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Sets the state of the Brick. Checks if the state being set is a freezing state and freezes/unfreezes the Brick.
             *
             * @method setState
             * @param {String} state a name of the state to set 
             * @return {Brick}           itself
             * @chainable
             */</span>
            setState: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(state)</span> </span>{
                <span class="hljs-keyword">this</span>.freeze(<span class="hljs-keyword">this</span>.freezeStates.indexOf(state) !== -<span class="hljs-number">1</span>);
                
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Display a (error) notice on the brick.
             *
             * @method displayNotice
             * @param  {Object} notice object with notice data to be passed to the template
             * @param  {String} [noticeTemplate] notice template name
             * @return {Brick}           itself
             * @chainable
             */</span>
            displayNotice: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(notice, noticeTemplate)</span> </span>{
                noticeTemplate = noticeTemplate || <span class="hljs-keyword">this</span>.noticeTemplate;

                <span class="hljs-keyword">if</span> (notice) {
                    <span class="hljs-keyword">this</span>.noticeNode
                        .empty()
                        .append(
                            template(noticeTemplate, notice)
                        );
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.noticeNode.empty();
                }

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Clears the Brick. This is an empty function. Bricks inheriting from this should override and provide their specific implementations.
             *
             * @method clear
             * @return {Brick}           itself
             * @chainable
             */</span>
            clear: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">this</span>.noticeNode.empty();

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the brick is valid. This is an empty function. Bricks inheriting from this should override and provide their specific implementations.
             *
             * @method isValid
             * @return {Boolean}           true if valid; false if not
             */</span>
            isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },

            <span class="hljs-comment">/**
             * Sets Brick's data. This is an empty function. Bricks inheriting from this should override and provide their specific implementations.
             *
             * @method setData
             * @return {Brick}           itself
             * @chainable
             */</span>
            setData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Returns Brick's data. Bricks inheriting from this should override and provide their one implementation and then call parent's getData method.
             *
             * @method getData
             * @param  {Object} [payload] data to be returned
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}         Brick's data
             */</span>
            getData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(payload, wrap)</span> </span>{
                <span class="hljs-keyword">var</span> result = {};

                payload = payload || {};

                <span class="hljs-keyword">if</span> (wrap) {
                    result[<span class="hljs-keyword">this</span>.id] = payload;
                } <span class="hljs-keyword">else</span> {
                    result = payload;
                }

                <span class="hljs-keyword">return</span> result;
            },

            freeze: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(freeze)</span> </span>{
                <span class="hljs-keyword">this</span>._isFrozen = freeze;
                <span class="hljs-keyword">this</span>.disable(freeze, <span class="hljs-literal">true</span>);
            },

            <span class="hljs-comment">/**
             * Disables or re-enables the Brick.
             * 
             * @method disable
             * @param  {Boolean} disable true to disable; false to enable
             * @param  {Boolean} force   if true, disables the brick even if it's frozen
             * @chainable
             * @return {Brick} itself
             * @for Brick
             */</span>
            disable: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(disable, force)</span> </span>{
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._isFrozen || force) {
                    <span class="hljs-keyword">if</span> (disable) {
                        <span class="hljs-keyword">this</span>.node</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>make the buttons appear and act as if they are disabled but still able to receive focus
it’s needed so keyboard focus wouldn’t fly away to the beginning of the page if the button is suddenly disabled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            .find(<span class="hljs-string">"button"</span>)
                            .addClass(<span class="hljs-string">"disabled"</span>)
                            .attr(<span class="hljs-string">"aria-disabled"</span>, <span class="hljs-literal">true</span>)
                            .end()
                            .find(<span class="hljs-string">"input, select"</span>)
                            .attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">true</span>);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">this</span>.node
                            .find(<span class="hljs-string">"button"</span>)
                            .removeClass(<span class="hljs-string">"disabled"</span>)
                            .attr(<span class="hljs-string">"aria-disabled"</span>, <span class="hljs-literal">false</span>)
                            .end()
                            .find(<span class="hljs-string">"input, select"</span>)
                            .attr(<span class="hljs-string">"disabled"</span>, <span class="hljs-literal">false</span>);
                    }
                }

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            }
        });

        <span class="hljs-comment">/**
        * The MultiBrick prototype. Used as a container for multiple independent Bricks if they are required to be displayed side by side.
        * To instantiate, call {{#crossLink "MultiBrick/new:method"}}{{/crossLink}} on the MultiBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class MultiBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends Brick
        * 
        */</span>
        MultiBrick = Brick.extend({
            <span class="hljs-comment">/**
             * A CSS class of the MultiBrick container node.
             *
             * @property containerClass
             * @for MultiBrick
             * @private
             * @type {String}
             * @default "multi-brick-container"
             */</span>
            
            <span class="hljs-comment">/**
             * A name of the default MultiBrick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default "default_multi_brick_template"
             */</span>

             <span class="hljs-comment">/**
             * A collection of Brick objects to be displayed side by side in the MultiBrick.
             *
             * @property content
             * @private
             * @type {Array}
             * @default []
             */</span>
            
            <span class="hljs-comment">/**
             * A MultiBrick container node.
             *
             * @property multiContainer
             * @private
             * @type {Object}
             */</span>
            
            <span class="hljs-comment">/**
             * A dictionary of the initialized content Brick objects for easy lookup. 
             *
             * @property contentBricks
             * @private
             * @type {Object}
             */</span>

            <span class="hljs-comment">/**
             * Initializes the MutliBrick by generating a specified template and setting defaults.
             * 
             * @method new
             * @param  {String} id     specified id of the MultiBrick
             * @param  {Object} config a configuration object for the MultiBrick
             * @param  {String} [config.content] a collection of bricks to be displayed in the MultiBrick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @retun MultiBrick
             * @chainable
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        template: <span class="hljs-string">"default_multi_brick_template"</span>,
                        containerClass: <span class="hljs-string">"multi-brick-container"</span>,
                        content: []
                    }
                );

                Brick.initialize.call(<span class="hljs-keyword">this</span>, id, config);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        multiContainer: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">".multi-container"</span>),
                        contentBricks: {}
                    }
                );</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>loop through the content and create Bricks and append them to the MultiBrick container</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.content.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(contentItem)</span> </span>{
                    <span class="hljs-keyword">var</span> contentBrick = contentItem.type.new(contentItem.id, contentItem.config);

                    that.contentBricks[contentBrick.id] = contentBrick;

                    <span class="hljs-keyword">if</span> (that.header) {
                        contentBrick.node = $(
                            contentBrick.node
                                .prop(<span class="hljs-string">'outerHTML'</span>).replace(<span class="hljs-string">"&lt;h3"</span>, <span class="hljs-string">"&lt;h4"</span>).replace(<span class="hljs-string">"&lt;/h3&gt;"</span>, <span class="hljs-string">"&lt;/h4&gt;"</span>)
                            )
                        ;
                    }

                    that.multiContainer.append(contentBrick.node);
                });
            },

            <span class="hljs-comment">/**
             * Sets the state of the MultiBrick by setting states of the individual bricks inside the MultiBrick using their specific setState methods.
             *
             * @method setState
             * @param {String} state a name of the state to set 
             * @return {MultiBrick}           itself
             * @chainable
             */</span>
            setState: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(state)</span> </span>{
                UtilDict.forEachEntry(<span class="hljs-keyword">this</span>.contentBricks, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, brick)</span> </span>{
                    brick.setState(state);
                });

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Clears the MultiBrick by clearing of the individual bricks inside the MultiBrick using their specific clear methods.
             *
             * @method clear
             * @return {MultiBrick}           itself
             * @chainable
             */</span>
            clear: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                UtilDict.forEachEntry(<span class="hljs-keyword">this</span>.contentBricks, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, brick)</span> </span>{
                    brick.clear();
                });

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the MultiBrick is valid. It's valid only if all individual bricks inside it are valid.
             *
             * @method isValid
             * @return {Boolean}           true if valid; false if not
             */</span>
            isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                UtilDict.forEachEntry(<span class="hljs-keyword">this</span>.contentBricks, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, brick)</span> </span>{
                    <span class="hljs-keyword">if</span> (!brick.isValid()) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                });

                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },

            <span class="hljs-comment">/**
             * Sets MultiBrick's data by setting data to the individual bricks inside it. Uses their own specific setData functions.
             *              *
             * @method setData
             * @param {Object} data
             * @return {MultiBrick}           itself
             * @chainable
             */</span>
            setData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
                UtilDict.forEachEntry(<span class="hljs-keyword">this</span>.contentBricks, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, brick)</span> </span>{
                    brick.setData(data);
                });

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Returns MultiBrick's data by mixing together data of the individual bricks inside using their specific getData methods and then passing it to the Brick's getData method for potential wrapping.
             *
             * @method getData
             * @for MultiBrick
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}         MultiBrick's data
             */</span>
            getData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(wrap)</span> </span>{
                <span class="hljs-keyword">var</span> payload = {};

                UtilDict.forEachEntry(<span class="hljs-keyword">this</span>.contentBricks, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, brick)</span> </span>{
                    lang.mixin(payload, brick.getData(<span class="hljs-literal">true</span>));
                });

                <span class="hljs-keyword">return</span> Brick.getData.call(<span class="hljs-keyword">this</span>, payload, wrap);
            }
        });

        <span class="hljs-comment">/**
        * ButtonBrick is just a Brick with a button inside it. The button can be styled and can be assigned an onClick event. 
        * To instantiate, call {{#crossLink "ButtonBrick/new:method"}}{{/crossLink}} on the ButtonBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class ButtonBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends Brick
        * 
        */</span>
        ButtonBrick = Brick.extend({
            
            <span class="hljs-comment">/**
             * A dictionary of possible ButtonBrick events. Add a CLICK event to the default Brick events.
             *
             * @property event
             * @for ButtonBrick
             * @type {Object}
             * @example
             *      event: {
             *          CHANGE: "brick/change",
             *          CLICK: "buttonBrick/click"
             *      }
             * 
             */</span>
            event: lang.mixin({}, Brick.event,
                {
                    <span class="hljs-comment">/**
                    * Published whenever a ButtonBrick is clicked.
                    *
                    * @event Bricks.ButtonBrick.event.CLICK
                    * @param data {Object} anything, usually result of calling getData() on the Brick
                    */</span>
                    CLICK: <span class="hljs-string">"buttonBrick/click"</span>
                }
            ),

            <span class="hljs-comment">/**
             * A CSS class of the MultiBrick container node.
             *
             * @property containerClass
             * @private
             * @type {String}
             * @default "button-brick-container"
             */</span>

            <span class="hljs-comment">/**
             * A name of the default ButtonBrick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default "default_button_brick_template"
             */</span>
            
            <span class="hljs-comment">/**
             * A CSS class of the button.
             *
             * @property buttonClass
             * @private
             * @type {String}
             * @default "btn-primary"
             */</span>
            
            <span class="hljs-comment">/**
             * A button label.
             *
             * @property label
             * @private
             * @type {String}
             * @default "Ok"
             */</span>

            <span class="hljs-comment">/**
             * Initializes the ButtonBrick by generating a specified template and setting defaults. Also sets a click listener on the template button.
             * ButtonBrick is a simple button in the Brick container.
             * 
             * @method new
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @param  {String} [config.buttonClass] a CSS class of the button in the ButtonBrick
             * @param  {String} [config.label] a button label
             * @chainable
             * @return {ButtonBrick}
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        template: <span class="hljs-string">"default_button_brick_template"</span>,
                        containerClass: <span class="hljs-string">"button-brick-container"</span>,
                        buttonClass: <span class="hljs-string">"btn-primary"</span>,
                        label: <span class="hljs-string">"Ok"</span>
                    }
                );

                Brick.initialize.call(<span class="hljs-keyword">this</span>, id, config);

                <span class="hljs-keyword">this</span>.node.on(<span class="hljs-string">"click"</span>, <span class="hljs-string">"button:not(.disabled)"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    that.notify(that.event.CLICK, <span class="hljs-literal">null</span>);
                });
            },

            <span class="hljs-comment">/**
             * Returns true. ButtonBrick is always valid
             *
             * @method isValid
             * @return {Boolean}           true
             */</span>
            isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },

            <span class="hljs-comment">/**
             * Returns ButtonBrick's data. Pretty useless function when you think of it. Just returns the data of the Brick prototype which is empty.
             *
             * @method getData
             * @for ButtonBrick
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}         ButtonBrick's data
             */</span>
            getData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(wrap)</span> </span>{
                <span class="hljs-keyword">var</span> payload = {};

                <span class="hljs-keyword">return</span> Brick.getData.call(<span class="hljs-keyword">this</span>, payload, wrap);
            }
        });
        
        <span class="hljs-comment">/**
        * The OkCancelButtonBrick prototype. A MultiBrick with two ButtonBricks displayed side by side and styled as OK and Cancel buttons.
        * To instantiate, call {{#crossLink "OkCancelButtonBrick/new:method"}}{{/crossLink}} on the OkCancelButtonBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class OkCancelButtonBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends MultiBrick
        */</span>
        OkCancelButtonBrick = MultiBrick.extend({
            
            <span class="hljs-comment">/**
             * A dictionary of possible OkCancelButtonBrick events. Adds a OK_CLICK and CANCEL_CLICK events to the default ButtonBrick events.
             *
             * @property event
             * @for OkCancelButtonBrick
             * @type {Object}
             * @example
             *      event: {
             *          CHANGE: "brick/change",
             *          CLICK: "buttonBrick/click",
             *          OK_CLICK: "okCancelButtonBrick/okClick",
             *          CANCEL_CLICK: "okCancelButtonBrick/cancelClick"
             *      }
             * 
             */</span>
            event: lang.mixin({},
                MultiBrick.event,
                ButtonBrick.event,
                {
                    <span class="hljs-comment">/**
                    * Published whenever an OK button of the OkCancelButtonBrick is clicked.
                    *
                    * @event Bricks.OkCancelButtonBrick.event.OK_CLICK
                    * @param data {Object} anything, usually result of calling getData() on the Brick
                    */</span>
                    OK_CLICK: <span class="hljs-string">"okCancelButtonBrick/okClick"</span>,
                    <span class="hljs-comment">/**
                    * Published whenever an Cancel button of the OkCancelButtonBrick is clicked
                    *
                    * @event Bricks.OkCancelButtonBrick.event.CANCEL_CLICK
                    * @param data {Object} anything, usually result of calling getData() on the Brick
                    */</span>
                    CANCEL_CLICK: <span class="hljs-string">"okCancelButtonBrick/cancelClick"</span>
                }
            ),

            <span class="hljs-comment">/**
             * A CSS class of the OkCancelButtonBrick container node.
             *
             * @property containerClass
             * @private
             * @type {String}
             * @default "okcancelbutton-brick-container"
             */</span>
            
            <span class="hljs-comment">/**
             * Default id of the OK button of the Brick, cannot be changed.
             *
             * @property okButtonId
             * @private
             * @type {String}
             * @default "okButton"
             */</span>

            <span class="hljs-comment">/**
             * Default id of the cancel button of the Brick, cannot be changed.
             *
             * @property cancelButtonId
             * @private
             * @type {String}
             * @default "cancelButton"
             */</span>

            <span class="hljs-comment">/**
             * Default id of the cancel button of the Brick, cannot be changed.
             *
             * @property cancelButtonId
             * @private
             * @type {String}
             * @default "cancelButton"
             */</span>
            
            <span class="hljs-comment">/**
             * Reverses the default visual order of OK, Cancel button to Cancel, OK.
             *
             * @property reverseOrder
             * @private
             * @type {Boolean}
             * @default "false"
             */</span>

            okButtonId: <span class="hljs-string">"okButton"</span>,
            cancelButtonId: <span class="hljs-string">"cancelButton"</span>,

            <span class="hljs-comment">/**
             * Initializes the OkCancelButtonBrick by generating a specified template and setting defaults. Also sets a click listener on the template button.
             * OkCancelButtonBrick is a brick with two preset buttons: OK and Cancel.
             * Button container classes are predefined as "ok-button-brick-container" and "cancel-button-brick-container"
             * 
             * @method new
             * @for OkCancelButtonBrick
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @param  {String} [config.buttonClass] a CSS class of the button in the OkCancelButtonBrick
             * @param  {String} [config.okLabel] an OK button label
             * @param  {String} [config.cancelLabel] a Cancel button label
             * @param  {String} [config.okButtonClass] an OK button CSS class
             * @param  {String} [config.cancelButtonClass] a Cancel button CSS class
             * @param  {String} [config.okFreezeStates] an OK button freeze states
             * @param  {String} [config.cancelFreezeStates] a Cancel button freeze states
             * @param  {String} [config.reverseOrder] reverses the default visual order of OK, Cancel button to Cancel, OK.
             * @chainable
             * @return {OkCancelButtonBrick}
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>,
                    newConfig;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>generating a MultiBrick config with two buttons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                newConfig =
                    {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>template: “default_okcancelbutton_brick_template”,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        containerClass: <span class="hljs-string">"okcancelbutton-brick-container"</span>,
                        header: config.header,
                        content: [
                            {
                                id: <span class="hljs-keyword">this</span>.okButtonId,
                                type: ButtonBrick,
                                config: {
                                    label: config.okLabel,
                                    containerClass: <span class="hljs-string">"ok-button-brick-container"</span>,
                                    buttonClass: <span class="hljs-string">"ok-btn "</span> + (config.okButtonClass || <span class="hljs-string">"btn-sm btn-primary"</span>),
                                    freezeStates: config.okFreezeStates || []
                                }
                            },
                            {
                                id: <span class="hljs-keyword">this</span>.cancelButtonId,
                                type: ButtonBrick,
                                config: {
                                    label: config.cancelLabel,
                                    containerClass: <span class="hljs-string">"cancel-button-brick-container"</span>,
                                    buttonClass: <span class="hljs-string">"cancel-btn "</span> + (config.cancelButtonClass || <span class="hljs-string">"btn-sm button-none"</span>),
                                    freezeStates: config.cancelFreezeStates || []
                                }
                            }
                        ],
                        required: config.required
                    };

                <span class="hljs-keyword">if</span> (config.reverseOrder) {
                    newConfig.content.reverse();
                }

                MultiBrick.initialize.call(<span class="hljs-keyword">this</span>, id, newConfig);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        okButtonBrick: <span class="hljs-keyword">this</span>.contentBricks[<span class="hljs-keyword">this</span>.okButtonId],
                        cancelButtonBrick: <span class="hljs-keyword">this</span>.contentBricks[<span class="hljs-keyword">this</span>.cancelButtonId]
                    }
                );</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>setting event listeners on individual ButtonBricks, not button nodes directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.okButtonBrick.on(<span class="hljs-keyword">this</span>.event.CLICK, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    that.notify(that.event.OK_CLICK, <span class="hljs-literal">null</span>);
                    that.notify(that.event.CLICK, <span class="hljs-literal">null</span>);
                });

                <span class="hljs-keyword">this</span>.cancelButtonBrick.on(<span class="hljs-keyword">this</span>.event.CLICK, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    that.notify(that.event.CANCEL_CLICK, <span class="hljs-literal">null</span>);
                    that.notify(that.event.CLICK, <span class="hljs-literal">null</span>);
                });
            }
        });

        <span class="hljs-comment">/**
        * The ChoiceBrick prototype. Provides a user the ability to choose a single item among several.
        * To instantiate, call {{#crossLink "ChoiceBrick/new:method"}}{{/crossLink}} on the ChoiceBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class ChoiceBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends Brick
        */</span>
        ChoiceBrick = Brick.extend({
            
            <span class="hljs-comment">/**
             * A CSS class of the MultiBrick container node.
             *
             * @property containerClass
             * @private
             * @for ChoiceBrick
             * @type {String}
             * @default "choice-brick-container"
             */</span>

            <span class="hljs-comment">/**
             * A name of the default ButtonBrick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default "default_choice_brick_template"
             */</span>
            
            <span class="hljs-comment">/**
             * Indicates which choice is currently selected
             *
             * @property selectedChoice
             * @private
             * @type {String}
             * @default null
             */</span>
            
            <span class="hljs-comment">/**
             * Indicates if the user made the selection or it was made programmatically
             *
             * @property userSelected
             * @private
             * @type {Boolean}
             * @default false
             */</span>

            <span class="hljs-comment">/**
             * A collection of choices that will be offered to the user. At least two choices are required for this Brick to have any use at all.
             *
             * @property choices
             * @private
             * @type {Array}
             * @example
             *     [
             *         {
             *             key: "ie9",
             *             value: "IE9"
             *         },
             *         {
             *             key: "chrome",
             *             value: "Chrome"
             *         }
             *     ]
             */</span>

            <span class="hljs-comment">/**
             * Initializes the ChoiceBrick by generating a specified template and setting defaults. Also sets a click listener on the template button.
             * The ChoiceBrick prototype. Provides a user the ability to choose a single item among several.
             * 
             * @method new
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @param  {Array} [config.choices] a set of choices that will be presented to the user
             * @chainable
             * @return {ChoiceBrick}
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        template: <span class="hljs-string">"default_choice_brick_template"</span>,
                        containerClass: <span class="hljs-string">"choice-brick-container"</span>
                    }
                );

                Brick.initialize.call(<span class="hljs-keyword">this</span>, id, config);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        selectedChoice: <span class="hljs-string">""</span>,
                        userSelected: <span class="hljs-literal">false</span>
                    }
                );

                <span class="hljs-keyword">this</span>.choiceButtons = <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">".btn-choice"</span>);

                <span class="hljs-keyword">this</span>.node.on(<span class="hljs-string">"click"</span>, <span class="hljs-string">".btn-choice:not(.button-pressed)"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
                    <span class="hljs-keyword">var</span> choiceKey = $(event.currentTarget).data(<span class="hljs-string">"key"</span>);
                    that.setChoice(choiceKey, <span class="hljs-literal">true</span>);
                });
            },

            <span class="hljs-comment">/**
             * Sets the choice of the ChoiceBrick.
             * 
             * @method setChoice
             * @param {String} choiceKey    string value of the choice to be selected
             * @param {Boolean} userSelected boolean value indicating if the user is the source of the selection
             * @return {ChoiceBrick}           itself
             * @chainable
             */</span>
            setChoice: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(choiceKey, userSelected)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>only set choice if it differs from the current one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (choiceKey !== <span class="hljs-keyword">this</span>.selectedChoice || (userSelected ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>) !== <span class="hljs-keyword">this</span>.userSelected) {

                    <span class="hljs-keyword">this</span>.userSelected = userSelected ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">this</span>.selectedChoice = choiceKey;

                    <span class="hljs-keyword">this</span>.choiceButtons
                        .removeClass(<span class="hljs-string">"button-pressed"</span>)
                        .filter(<span class="hljs-string">"[data-key='"</span> + choiceKey + <span class="hljs-string">"']"</span>)
                        .addClass(<span class="hljs-string">"button-pressed"</span>);

                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"ChoiceBrick-"</span> + <span class="hljs-keyword">this</span>.id, <span class="hljs-string">":"</span>, <span class="hljs-keyword">this</span>.selectedChoice, <span class="hljs-string">"; userSelected:"</span>, <span class="hljs-keyword">this</span>.userSelected);

                    <span class="hljs-keyword">this</span>.notify(<span class="hljs-keyword">this</span>.event.CHANGE, <span class="hljs-keyword">this</span>.getData());
                }

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the option was selected by the user or not.
             * 
             * @method isUserSelected
             * @return {Boolean} true if the option was selected by the user; false, otherwise
             * @return {ChoiceBrick}           itself
             * @chainable
             */</span>
            isUserSelected: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userSelected;
            },

            <span class="hljs-comment">/**
             * Clears the ChoiceBrick by reseting selectedChoice to an empty string and userSelected to false.
             *
             * @method clear
             * @return {ChoiceBrick}           itself
             * @chainable
             */</span>
            clear: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">this</span>.setChoice(<span class="hljs-string">""</span>, <span class="hljs-literal">false</span>);

                Brick.clear.call(<span class="hljs-keyword">this</span>);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the brick is valid. The ChoiceBrick is considered valid if selectedChoice is not an empty String.
             *
             * @method isValid
             * @return {Boolean}           true if valid; false if not
             */</span>
            isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selectedChoice !== <span class="hljs-string">""</span>;
            },

            <span class="hljs-comment">/**
             * Sets ChoiceBrick's data. First calls setChoice and calls set data on the Brick prototype.
             *
             * @method setData
             * @param {Object} data a wrapper object for the data to be set.  
             * @return {ChoiceBrick}           itself
             * @chainable
             */</span>
            setData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
                <span class="hljs-keyword">this</span>.setChoice(data.selectedChoice, data.userSelected);

                Brick.setData.call(data);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Returns ChoiceBrick's data.
             * 
             * @method getData
             * @for ChoiceBrick
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}  A wrapper object around two properties: selectedChoice and userSelected
             */</span>
            getData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(wrap)</span> </span>{
                <span class="hljs-keyword">var</span> payload = {
                    selectedChoice: <span class="hljs-keyword">this</span>.selectedChoice,
                    userSelected: <span class="hljs-keyword">this</span>.userSelected
                };

                <span class="hljs-keyword">return</span> Brick.getData.call(<span class="hljs-keyword">this</span>, payload, wrap);
            }
        });

        <span class="hljs-comment">/**
        * The SimpleInputBrick prototype. Provides a control for a simple text input. Can be potentially extended to serve more specific purposes.
        * To instantiate, call {{#crossLink "SimpleInputBrick/new:method"}}{{/crossLink}} on the SimpleInputBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class SimpleInputBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends Brick
        */</span>
        SimpleInputBrick = Brick.extend({
            <span class="hljs-comment">/**
             * A CSS class of the SimpleInputBrick container node.
             *
             * @property containerClass
             * @private
             * @for SimpleInputBrick
             * @type {String}
             * @default "simpleinput-brick-container"
             */</span>

            <span class="hljs-comment">/**
             * A name of the default SimpleInputBrick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default "default_simpleinput_brick_template"
             */</span>

             <span class="hljs-comment">/**
             * An input field label. Invisible. Defaults to the Brick's header.
             *
             * @property label
             * @private
             * @type {String}
             * @default ""
             */</span>
            
            <span class="hljs-comment">/**
             * A placeholder to be displayed inside the input field.
             *
             * @property placeholder
             * @private
             * @type {String}
             * @default ""
             */</span>

            <span class="hljs-comment">/**
             * A string that is currently entered in the input field
             *
             * @property inputValue
             * @private
             * @type {String}
             * @default ""
             */</span>
            
            <span class="hljs-comment">/**
             * Indicates if the user entered text into the input field or it was entered programmatically
             *
             * @property userEntered
             * @private
             * @type {Boolean}
             * @default false
             */</span>

            <span class="hljs-comment">/**
             * Initializes the SimpleInputBrick by generating a specified template and setting defaults.
             * This Brick fires a CHANGE event on every change inside the input field.
             * 
             * @method new
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @param  {String} [config.label] an input field label. Invisible. Defaults to the Brick's header
             * @param  {String} [config.placeholder] a placeholder to be displayed inside the input field
             * @retun SimpleInputBrick
             * @chainable
             * 
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        template: <span class="hljs-string">"default_simpleinput_brick_template"</span>,
                        containerClass: <span class="hljs-string">"simpleinput-brick-container"</span>,
                        guid: UtilMisc.guid(),
                        label: config.header
                    }
                );

                Brick.initialize.call(<span class="hljs-keyword">this</span>, id, config);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        inputValue: <span class="hljs-string">""</span>,
                        userEntered: <span class="hljs-literal">false</span>,
                        formGroup: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">".form-group"</span>),
                        inputNode: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">"input[type='text']#"</span> + <span class="hljs-keyword">this</span>.guid)
                    }
                );</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>setting a listener on the input field</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.inputNode.on(<span class="hljs-string">"input"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
                    <span class="hljs-keyword">var</span> value = $(event.target).val();
                    that.setInputValue(value, <span class="hljs-literal">true</span>);
                });
            },

            <span class="hljs-comment">/**
             * Sets the current value of the input field.
             * 
             * @method setInputValue
             * @param {String} value    string value to be entered into the input field
             * @param {Boolean} userEntered boolean value indicating if the user is the source of the string value
             * @return {SimpleInputBrick}           itself
             * @chainable
             */</span>
            setInputValue: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, userEntered)</span> </span>{
                <span class="hljs-keyword">this</span>.userEntered = userEntered ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">this</span>.inputValue = value;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>if user entered it, the text is already in the field;
if not, need to populate the field</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!userEntered) {
                    <span class="hljs-keyword">this</span>.inputNode.val(value);
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>fire change event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.notify(<span class="hljs-keyword">this</span>.event.CHANGE, <span class="hljs-keyword">this</span>.getData());

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the input value was entered by the user or not.
             * 
             * @method isUserEntered
             * @return {Boolean} true if the input value was entered by the user; false, otherwise
             */</span>
            isUserEntered: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userEntered;
            },

            <span class="hljs-comment">/**
             * Sets the state of the Brick. Depending on the state, update the visual styles of the input field.
             * Then call the Brick prototype setState function.
             * 
             * @method setState
             * @param {String} state a name of the state to set 
             * @return {SimpleInputBrick}           itself
             * @chainable
             */</span>
            setState: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(state)</span> </span>{

                <span class="hljs-keyword">switch</span> (state) {
                    <span class="hljs-keyword">case</span> <span class="hljs-keyword">this</span>.state.SUCCESS:
                        <span class="hljs-keyword">this</span>.formGroup.addClass(<span class="hljs-string">"has-feedback has-success"</span>);
                        <span class="hljs-keyword">break</span>;

                    <span class="hljs-keyword">case</span> <span class="hljs-keyword">this</span>.state.ERROR:
                        <span class="hljs-keyword">this</span>.formGroup.addClass(<span class="hljs-string">"has-feedback has-error"</span>);
                        <span class="hljs-keyword">break</span>;

                    <span class="hljs-keyword">case</span> <span class="hljs-keyword">this</span>.state.DEFAULT:
                        <span class="hljs-keyword">this</span>.formGroup.removeClass(<span class="hljs-string">"has-feedback has-success has-error"</span>);
                        <span class="hljs-keyword">break</span>;

                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">break</span>;
                }

                Brick.setState.call(<span class="hljs-keyword">this</span>, state);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Clears the Brick by setting inputValue to "" and userEntered to false.
             *
             * @method clear
             * @return {SimpleInputBrick}           itself
             * @chainable
             */</span>
            clear: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">this</span>.setInputValue(<span class="hljs-string">""</span>, <span class="hljs-literal">false</span>);

                Brick.clear.call(<span class="hljs-keyword">this</span>);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the SimpleInputBrick is valid. It's considered valid if the input value is not an empty String.
             *
             * @method isValid
             * @return {Boolean}           true if valid; false if not
             */</span>
            isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.inputValue !== <span class="hljs-string">""</span>;
            },

            <span class="hljs-comment">/**
             * Sets SimpleInputBrick's data. First calls setInputValue and calls set data on the Brick prototype.
             *
             * @method setData
             * @param {Object} data a wrapper object for the data to be set.  
             * @return {SimpleInputBrick}           itself
             * @chainable
             */</span>
            setData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
                <span class="hljs-keyword">this</span>.setInputValue(data.inputValue, data.userEntered);

                Brick.setData.call(data);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Returns SimpleInputBrick's data.
             * 
             * @method getData
             * @for SimpleInputBrick
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}  A wrapper object around two properties: inputValue and userEntered
             */</span>
            getData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(wrap)</span> </span>{
                <span class="hljs-keyword">var</span> payload = {
                    inputValue: <span class="hljs-keyword">this</span>.inputValue,
                    userEntered: <span class="hljs-keyword">this</span>.userEntered
                };

                <span class="hljs-keyword">return</span> Brick.getData.call(<span class="hljs-keyword">this</span>, payload, wrap);
            }
        });
    
        <span class="hljs-comment">/**
        * The DropDownBrick prototype. Provides a dropdown control to choose an item from.
        * To instantiate, call {{#crossLink "DropDownBrick/new:method"}}{{/crossLink}} on the DropDownBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class DropDownBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends Brick
        */</span>
        DropDownBrick = Brick.extend({
            <span class="hljs-comment">/**
             * A CSS class of the DropDownBrick container node.
             *
             * @property containerClass
             * @private
             * @for DropDownBrick
             * @type {String}
             * @default "dropdown-brick-container"
             */</span>

            <span class="hljs-comment">/**
             * A name of the default DropDownBrick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default "default_dropdown_brick_template"
             */</span>
            
            <span class="hljs-comment">/**
             * An input field label. Invisible. Defaults to the Brick's header.
             *
             * @property label
             * @private
             * @type {String}
             * @default ""
             */</span>

            <span class="hljs-comment">/**
             * A value of the currently selected item in the dropdown.
             *
             * @property dropDownValue
             * @private
             * @type {String}
             * @default ""
             */</span>
            
            <span class="hljs-comment">/**
             * A text string of the currently selected item in the dropdown.
             *
             * @property dropDownText
             * @private
             * @type {String}
             * @default ""
             */</span>

            <span class="hljs-comment">/**
             * Indicates if the user selected the option in the dropdown or it was selected programmatically.
             *
             * @property userSelected
             * @private
             * @type {Boolean}
             * @default false
             */</span>

            <span class="hljs-comment">/**
             * Initializes the DropDownBrick by generating a specified template and setting defaults.
             * This Brick fires a CHANGE event on every change inside the dropdown.
             * 
             * @method new
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @retun DropDownBrick
             * @chainable
             * 
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        template: <span class="hljs-string">"default_dropdown_brick_template"</span>,
                        containerClass: <span class="hljs-string">"dropdown-brick-container"</span>,
                        guid: UtilMisc.guid(),
                        label: config.header
                    }
                );

                Brick.initialize.call(<span class="hljs-keyword">this</span>, id, config);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        dropDownValue: <span class="hljs-string">""</span>,
                        dropDownText: <span class="hljs-string">""</span>,
                        userSelected: <span class="hljs-literal">false</span>,
                        selectNode: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">"select#"</span> + <span class="hljs-keyword">this</span>.guid)
                    }
                );</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>setting event listener on <select> node; “change” is the most appropriate
<a href="https://developer.mozilla.org/en-US/docs/Web/Events/change">https://developer.mozilla.org/en-US/docs/Web/Events/change</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.selectNode.on(<span class="hljs-string">"change"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">var</span> option = that.selectNode.find(<span class="hljs-string">"option:selected"</span>);

                    that.setDropDownValue(option, <span class="hljs-literal">true</span>);
                });

                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options) {
                    <span class="hljs-keyword">this</span>.setDropDownOptions(<span class="hljs-keyword">this</span>.options);
                }
            },

            <span class="hljs-comment">/**
             * Selects the option whose value is provided in selectedOption param;
             * 
             * @method selectOption
             * @param {String} selectedOption    string value to be selected in the dropdown
             * @param {Boolean} userSelected boolean value indicating if the user is the source of the string value
             * @return {DropDownBrick}           itself
             * @chainable
             */</span>
            selectOption: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(selectedOption, userSelected)</span> </span>{
                <span class="hljs-keyword">var</span> option = <span class="hljs-keyword">this</span>.selectNode.find(<span class="hljs-string">"option[value='"</span> + selectedOption + <span class="hljs-string">"']"</span>);

                <span class="hljs-keyword">this</span>.selectNode.val(selectedOption);
                <span class="hljs-keyword">this</span>.setDropDownValue(option, userSelected);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Stores selected option's text and value and notifies any listeners of the change.
             * Internal should not be called from outside.
             * 
             * @method setDropDownValue
             * @private
             * @param {String} option    string value to be selected in the dropdown
             * @param {Boolean} userSelected boolean value indicating if the user is the source of the string value
             * @return {DropDownBrick}           itself
             * @chainable
             */</span>
            setDropDownValue: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(option, userSelected)</span> </span>{
                <span class="hljs-keyword">var</span> value = option.val(),
                    text = option.find(<span class="hljs-string">"option:selected"</span>).text();

                <span class="hljs-keyword">this</span>.userSelected = userSelected ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">this</span>.dropDownValue = value;
                <span class="hljs-keyword">this</span>.dropDownText = text;

                <span class="hljs-keyword">this</span>.notify(<span class="hljs-keyword">this</span>.event.CHANGE, <span class="hljs-keyword">this</span>.getData());

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Populates the drop down with provided set of options optionally replacing or appending them to the existing options.
             * 
             * @method setDropDownOptions
             * @param {Array} options an array of options(Object) in the form of { value: [value], text: [text] }
             * @param {Boolean} [append]  Indicates whether to append to or replace the existing options
             * @return {DropDownBrick}           itself
             */</span>
            setDropDownOptions: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options, append)</span> </span>{
                UtilMisc.setSelectOptions(<span class="hljs-keyword">this</span>.selectNode, options, append);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the option was selected by the user or not.
             * 
             * @method isUserSelected
             * @return {Boolean} true if the option was selected by the user; false, otherwise
             * @return {DropDownBrick}           itself
             * @chainable
             */</span>
            isUserSelected: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userSelected;
            },

            <span class="hljs-comment">/**
             * Clears the DropDownBrick by setting the selected option to "" and userSelected to false.
             *
             * @method clear
             * @return {DropDownBrick}           itself
             * @chainable
             */</span>
            clear: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">this</span>.selectOption(<span class="hljs-string">""</span>);

                Brick.clear.call(<span class="hljs-keyword">this</span>);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the DropDownBrick is valid. It's considered valid if the selected option's value is not "".
             *
             * @method isValid
             * @return {Boolean}           true if valid; false if not
             */</span>
            isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dropDownValue !== <span class="hljs-string">""</span>;
            },

            <span class="hljs-comment">/**
             * Sets DropDownBrick's data.
             * data object may contain:
             *  - {Object} options an array of options to be added to the dropdown
             *  - {Boolean} append indicates whether to append or replace the exiting options
             *  - {String} selectedOption string value of the option that should be preselected (either old or newly added option)
             *  - {Boolean} userSelected boolean value indicating if the user is the source of the string value
             *
             * By default, after appending/replacing options, the first option will be selected unless specified otherwise.
             *
             * @method setData
             * @param {Object} data a wrapper object for the data to be set.
             * @return {DropDownBrick}           itself
             * @chainable
             */</span>
            setData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{

                <span class="hljs-keyword">if</span> (data.options) {
                    <span class="hljs-keyword">this</span>.setDropDownOptions(data.options, data.append);
                }

                <span class="hljs-keyword">if</span> (data.selectedOption) {
                    <span class="hljs-keyword">this</span>.selectOption(data.selectedOption, data.userSelected);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.options &amp;&amp; data.options.length &gt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">this</span>.selectOption(data.options[<span class="hljs-number">0</span>].value, <span class="hljs-literal">false</span>);
                }

                Brick.setData.call(data);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Returns DropDownBrick's data.
             * 
             * @method getData
             * @for DropDownBrick
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}  A wrapper object around two properties: inputValue and userEntered
             */</span>
            getData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(wrap)</span> </span>{
                <span class="hljs-keyword">var</span> payload = {
                    dropDownValue: <span class="hljs-keyword">this</span>.dropDownValue,
                    dropDownText: <span class="hljs-keyword">this</span>.dropDownText,
                    userSelected: <span class="hljs-keyword">this</span>.userSelected
                };

                <span class="hljs-keyword">return</span> Brick.getData.call(<span class="hljs-keyword">this</span>, payload, wrap);
            }
        });
    
        <span class="hljs-comment">/**
        * The ColorPickerBrick prototype. Provides a control to select a color.
        * To instantiate, call {{#crossLink "ColorPickerBrick/new:method"}}{{/crossLink}} on the ColorPickerBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class ColorPickerBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends SimpleInputBrick
        * 
        */</span>
        ColorPickerBrick = SimpleInputBrick.extend({
            <span class="hljs-comment">/**
             * A CSS class of the ColorPickerBrick container node.
             *
             * @property containerClass
             * @private
             * @for ColorPickerBrick
             * @type {String}
             * @default "colorpicker-brick-container"
             */</span>

            <span class="hljs-comment">/**
             * A name of the default ColorPickerBrick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default "default_colorpicker_brick_template"
             */</span>
            
            <span class="hljs-comment">/**
             * Specifies positions of the actual color picker (square wheel) control 
             *
             * @property pickerPosition
             * @private
             * @type {String}
             * @default "top"
             */</span>

             <span class="hljs-comment">/**
             * The actual node of the picker control.
             *
             * @property picker
             * @private
             * @type {Object}
             */</span>
            
            <span class="hljs-comment">/**
             * A sample node that is coloured with the selected colour.
             *
             * @property pickerSwatch
             * @private
             * @type {String}
             */</span>
            
            <span class="hljs-comment">/**
             * Initializes the ColorPickerBrick by generating a specified template and setting defaults.
             * A random colour is picked as when this Brick is instantiated.
             * This Brick fires a CHANGE event on every time the selected colour changes.
             * 
             * @method new
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @param  {String} [config.label] an input field label. Invisible. Defaults to the Brick's header
             * @param  {String} [config.placeholder] a placeholder to be displayed inside the input field
             * @param  {String} [config.pickerPosition] specifies positions of the actual color picker (square wheel) control
             * @retun ColorPickerBrick
             * @chainable
             * 
             */</span>
            initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, config)</span> </span>{
                <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>,
                    newConfig = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>mixin defaults with the given config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                lang.mixin(newConfig,
                    {
                        template: <span class="hljs-string">"default_colorpicker_brick_template"</span>,
                        containerClass: <span class="hljs-string">"colorpicker-brick-container"</span>,
                        guid: UtilMisc.guid(),
                        label: config.header,

                        pickerPosition: <span class="hljs-string">"top"</span>
                    },
                    config
                );

                SimpleInputBrick.initialize.call(<span class="hljs-keyword">this</span>, id, newConfig);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        picker: <span class="hljs-literal">null</span>,
                        pickerSwatch: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">"#"</span> + <span class="hljs-keyword">this</span>.guid + <span class="hljs-string">"pickerSwatch"</span>)
                    }
                );</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>create the picker control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.picker = <span class="hljs-keyword">new</span> jscolor.color(<span class="hljs-keyword">this</span>.inputNode[<span class="hljs-number">0</span>], {
                    pickerPosition: <span class="hljs-string">"top"</span>,
                    styleElement: <span class="hljs-keyword">this</span>.pickerSwatch[<span class="hljs-number">0</span>], <span class="hljs-comment">//this.guid + "pickerSwatch",</span>
                    onImmediateChange: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                        that.notify(that.event.CHANGE, that.getData());
                    }
                });</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>generate random colour</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.picker.fromString((<span class="hljs-keyword">new</span> RColor()).get(<span class="hljs-literal">true</span>).slice(<span class="hljs-number">1</span>));

                <span class="hljs-keyword">this</span>.pickerSwatch.on(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    that.picker.showPicker();
                });

            },

            setInputValue: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>chill</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            },<span class="hljs-comment">/*

            isValid: function () {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>TODO: if allowing color picker to start empty, need to check it’s validity; otherwise, it’s always valid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            }*/

            /*setData: function (data) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>TODO: allow to set colors programmatically
this.setInputValue(data.value, ?data.userEntered?);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                return this;
            },*/

            /**
             * Returns ColorPickerBrick's data.
             * Returns different colour representations:
             *  - {String} hex hexcode
             *  - {Array} rgb array of rgb colours (from 0 to 1)
             *  - {Array} rgb_ array of rgb colours (from 0 to 255)
             *  - {Array} hsv array of hsv colours (from 0 to 1)
             * 
             * @method getData
             * @for ColorPickerBrick
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}  A wrapper object around two properties: inputValue and userEntered
             */
            getData: function (wrap) {
                var payload = {
                    hex: this.picker.toString(),
                    rgb: this.picker.rgb,
                    rgb_: this.picker.rgb.map(function (c) { return Math.round(c * 255); }), // also return a proper rgb
                    hsv: this.picker.hsv
                };

                return Brick.getData.call(this, payload, wrap);
            }
        });
        
        /**
        * The FileInputBrick prototype extends SimpleInputBrick. Provides a control to either select a local file or enter its URL.
        * To instantiate, call {{#crossLink "FileInputBrick/new:method"}}{{/crossLink}} on the FileInputBrick prototype.
        *
        * 
        * ####Imports RAMP Modules:
        * {{#crossLink "Util"}}{{/crossLink}}  
        * {{#crossLink "TmplHelper"}}{{/crossLink}}  
        * {{#crossLink "Array"}}{{/crossLink}}  
        * {{#crossLink "Dictionary"}}{{/crossLink}}  
        *  
        * ####Uses RAMP Templates:
        * {{#crossLink "templates/bricks_template.json"}}{{/crossLink}}
        * 
        * 
        * @class FileInputBrick
        * @for Bricks
        * @static
        * @uses dojo/_base/lang
        * @extends SimpleInputBrick
        */
        FileInputBrick = SimpleInputBrick.extend({
            /**
             * A CSS class of the FileInputBrick container node.
             *
             * @property containerClass
             * @private
             * @for FileInputBrick
             * @type {String}
             * @default "fileinput-brick-container"
             */

            /**
             * A name of the default FileInputBrick template.
             *
             * @property template
             * @private
             * @type {String}
             * @default "default_fileinput_brick_template"
             */
            
            /**
             * A file object that is selected through FileAPI.
             *
             * @property fileValue
             * @private
             * @type {Object}
             * @default null
             */
            
            /**
             * A flag indicating if the user has selected the file or the file has been selected using some magical means.
             *
             * @property userSelected
             * @private
             * @type {Boolean}
             * @default false
             */
            
            /**
             * A browse files container node
             *
             * @property browseFilesContainer
             * @private
             * @type {Object}
             */
            
            /**
             * A node of the file input control.
             *
             * @property fileNode
             * @private
             * @type {Object}
             */
            
            /**
             * A node of the styled pseudo file input control that just looks nice and doesn't do anything. 
             *
             * @property filePseudoNode
             * @private
             * @type {Object}
             */

            /**
             * Initializes the FileInputBrick by generating a specified template and setting defaults.
             * This Brick fires a CHANGE event on every change inside the input field and on every file selected.
             * 
             * @method new
             * @param  {String} id     specified id of the Brick
             * @param  {Object} config a configuration object for the Brick
             * @param  {String} [config.header] a Brick header
             * @param  {String} [config.instructions] a configuration object for the Brick
             * @param  {Array|Object} [config.required] collection of rules specifying what external conditions must be valid for the Brick to be enabled
             * @param  {Array} [config.freezeStates] a set of rules specifying states Brick should be frozen
             * @param  {String} [config.baseTemplate] a base template name to be used
             * @param  {String} [config.noticeTemplate] a notice template name to be used
             * @param  {String} [config.containerClass] a CSS class of the specific brick container
             * @param  {String} [config.template] a name of the specific Brick template
             * @param  {String} [config.label] an input field label. Invisible. Defaults to the Brick's header
             * @param  {String} [config.placeholder] a placeholder to be displayed inside the input field
             * @retun FileInputBrick
             * @chainable
             * 
             */
            initialize: function (id, config) {
                var that = this,
                    newConfig = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>mixin defaults with the given config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                lang.mixin(newConfig,
                    {
                        template: <span class="hljs-string">"default_fileinput_brick_template"</span>,
                        containerClass: <span class="hljs-string">"fileinput-brick-container"</span>,
                        guid: UtilMisc.guid(),
                        label: config.header
                    },
                    config
                );

                SimpleInputBrick.initialize.call(<span class="hljs-keyword">this</span>, id, newConfig);

                lang.mixin(<span class="hljs-keyword">this</span>,
                    {
                        fileValue: <span class="hljs-literal">null</span>,
                        userSelected: <span class="hljs-literal">false</span>,
                        browseFilesContainer: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">".browse-files"</span>),
                        fileNode: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">"input[type='file']#"</span> + <span class="hljs-keyword">this</span>.guid + <span class="hljs-string">"realBrowse"</span>),
                        filePseudoNode: <span class="hljs-keyword">this</span>.node.find(<span class="hljs-string">"#"</span> + <span class="hljs-keyword">this</span>.guid + <span class="hljs-string">"pseudoBrowse"</span>)
                    }
                );</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>style the pseudoBrowse control to act as a normal button control</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                UtilMisc.styleBrowseFilesButton(<span class="hljs-keyword">this</span>.browseFilesContainer);

                <span class="hljs-keyword">this</span>.fileNode.on(<span class="hljs-string">"change"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
                    <span class="hljs-keyword">var</span> file = event.target.files[<span class="hljs-number">0</span>];

                    that.setFileValue(file, <span class="hljs-literal">true</span>);
                });
            },

            <span class="hljs-comment">/**
             * Sets the current value of the input field. In this case it's a file URL.
             * If the URL is set, the returned file object is null.
             *
             * First calls setFileValue(null, false) to null the file object, then calls the prototype's setInputValue with the same parameters.
             * 
             * @method setInputValue
             * @param {String} value    string value to be entered into the input field
             * @param {Boolean} userEntered boolean value indicating if the user is the source of the string value
             * @return {FileInputBrick}           itself
             * @chainable
             */</span>
            setInputValue: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, userEntered)</span> </span>{
                <span class="hljs-keyword">this</span>.setFileValue(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);

                SimpleInputBrick.setInputValue.call(<span class="hljs-keyword">this</span>, value, userEntered);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Sets file value of the Brick. When setting file object, input value is set to "". If value is null, the form is reset.
             * 
             * @method setFileValue
             * @param {Object} value        the selected file object
             * @param {Boolean} userSelected boolean value indicating if the user selected the file
             * @return {FileInputBrick}           itself
             * @chainable
             */</span>
            setFileValue: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, userSelected)</span> </span>{
                <span class="hljs-keyword">this</span>.userSelected = userSelected ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">this</span>.fileValue = value;
                <span class="hljs-keyword">this</span>.filePseudoNode.toggleClass(<span class="hljs-string">"selected"</span>, <span class="hljs-keyword">this</span>.fileValue ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);

                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fileValue) {
                    SimpleInputBrick.setInputValue.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.fileValue.name, <span class="hljs-literal">false</span>);

                    <span class="hljs-keyword">this</span>.notify(<span class="hljs-keyword">this</span>.event.CHANGE, <span class="hljs-keyword">this</span>.getData());
                } <span class="hljs-keyword">else</span> {
                    UtilMisc.resetFormElement(<span class="hljs-keyword">this</span>.fileNode);
                }

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the file was selected by the user or not.
             * 
             * @method isUserSelected
             * @return {Boolean} true if the file was selected by the user; false, otherwise
             */</span>
            isUserSelected: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userSelected;
            },

            <span class="hljs-comment">/**
             * Clears the Brick by setting inputValue to "" which sets fileValue to null and userEntered to false.
             *
             * @method clear
             * @return {FileInputBrick}           itself
             * @chainable
             */</span>
            clear: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">this</span>.setInputValue(<span class="hljs-string">""</span>, <span class="hljs-literal">false</span>);

                Brick.clear.call(<span class="hljs-keyword">this</span>);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Checks if the FileInputBrick is valid. It's considered valid if the input value is not "" or a file value is not null. 
             *
             * @method isValid
             * @return {Boolean}           true if valid; false if not
             */</span>
            isValid: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> SimpleInputBrick.isValid.call(<span class="hljs-keyword">this</span>) || <span class="hljs-keyword">this</span>.fileValue ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
            },

            <span class="hljs-comment">/**
             * Sets SimpleInputBrick's data. First calls setInputValue and calls set data on the Brick prototype.
             * data object may contain:
             *  - {Object} fileValue a file object 
             *  - {String} inputValue a input value (file URL)
             *  - {Boolean} userSelected boolean value indicating if the user is the source of the file value
             *  - {Boolean} userEntered boolean value indicating if the user is the source of the string value
             *
             * if both fileValue and inputValue are specified, only fileValue is used.
             * 
             * @method setData
             * @param {Object} data a wrapper object for the data to be set.  
             * @return {FileInputBrick}           itself
             * @chainable
             */</span>
            setData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
                <span class="hljs-keyword">if</span> (data.fileValue) {
                    <span class="hljs-keyword">this</span>.setFileValue(data.fileValue, data.userSelected);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.inputValue) {
                    <span class="hljs-keyword">this</span>.setInputValue(data.inputValue, data.userEntered);
                }

                SimpleInputBrick.setData.call(data);

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },

            <span class="hljs-comment">/**
             * Returns FileInputBrick's data. Either a file object or a file URL will be returned along with the file name, not both.
             *
             * Returns an object:
             *  - {Object} fileValue file object if any was selected
             *  - {String} fileName derived file name
             *  - {Boolean} userSelected a flag indicating if the user has selected the file or typed the URL
             * 
             * @method getData
             * @for FileInputBrick
             * @param  {Boolean} [wrap]    indicates of the payload should be wrapped with a Brick's id; useful when collection information from several Bricks at once. 
             * @return {Object}  A wrapper object around two properties: inputValue and userEntered
             */</span>
            getData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(wrap)</span> </span>{
                <span class="hljs-keyword">var</span> payload = SimpleInputBrick.getData.call(<span class="hljs-keyword">this</span>);

                lang.mixin(payload,
                    {
                        fileValue: <span class="hljs-keyword">this</span>.fileValue,</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>derive the file name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        fileName: <span class="hljs-keyword">this</span>.fileValue ? <span class="hljs-keyword">this</span>.fileValue.name : <span class="hljs-keyword">this</span>.inputValue.split(<span class="hljs-string">"/"</span>).pop(),
                        userSelected: <span class="hljs-keyword">this</span>.userSelected
                    }
                );

                <span class="hljs-keyword">return</span> Brick.getData.call(<span class="hljs-keyword">this</span>, payload, wrap);
            }
        });

        <span class="hljs-keyword">return</span> {

            <span class="hljs-comment">/**
             * The basic Brick prototype with no special functions. A base from all other Bricks.
             *
             * @for Bricks
             * @property Brick
             * @static
             * @type Brick
             */</span>
            Brick: Brick,

            <span class="hljs-comment">/**
             * The MultiBrick prototype. Used as a container for multiple independent Bricks if they are required to be displayed side by side.
             *
             * @property MultiBrick
             * @static
             * @type MultiBrick
             */</span>
            MultiBrick: MultiBrick,

            <span class="hljs-comment">/**
             * The ButtonBrick prototype. A simple Brick with a button template.
             *
             * @property ButtonBrick
             * @static
             * @type ButtonBrick
             */</span>
            ButtonBrick: ButtonBrick,
            <span class="hljs-comment">/**
             * The OkCancelButtonBrick prototype. A MultiBrick with two ButtonBricks displayed side by side and styled as OK and Cancel buttons.
             *
             * @property OkCancelButtonBrick
             * @static
             * @type OkCancelButtonBrick
             */</span>
            OkCancelButtonBrick: OkCancelButtonBrick,

            <span class="hljs-comment">/**
             * The ChoiceBrick prototype. Provides a user the ability to choose a single item among several.
             *
             * @property ChoiceBrick
             * @static
             * @type ChoiceBrick
             */</span>
            ChoiceBrick: ChoiceBrick,

            <span class="hljs-comment">/**
             * The DropDownBrick prototype. Provides a dropdown control to choose an item from.
             *
             * @property DropDownBrick
             * @static
             * @type DropDownBrick
             */</span>
            DropDownBrick: DropDownBrick,
            <span class="hljs-comment">/**
             * The ColorPickerBrick prototype. Provides a control to select a color.
             *
             * @property ColorPickerBrick
             * @static
             * @type ColorPickerBrick
             */</span>
            ColorPickerBrick: ColorPickerBrick,
            <span class="hljs-comment">/**
             * The SimpleInputBrick prototype. Provides a control for a simple text input. Can be potentially extended to serve more specific purposes.
             *
             * @property SimpleInputBrick
             * @static
             * @type SimpleInputBrick
             */</span>
            SimpleInputBrick: SimpleInputBrick,
            <span class="hljs-comment">/**
             * The FileInputBrick prototype extends SimpleInputBrick. Provides a control to either select a local file or enter its URL.
             *
             * @property FileInputBrick
             * @static
             * @type FileInputBrick
             */</span>
            FileInputBrick: FileInputBrick
        };
    });</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
