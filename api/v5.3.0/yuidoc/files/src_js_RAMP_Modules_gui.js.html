<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/js/RAMP/Modules/gui.js - ramp-pcar</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../../assets/images/bobcat_logo_sharp_smaller_s.png" title="ramp-pcar">Reusable Accessible Mapping Platform</h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.3.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AdvancedToolbar.html">AdvancedToolbar</a></li>
            
                <li><a href="../classes/AreaTool.html">AreaTool</a></li>
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/BaseMapSelector.html">BaseMapSelector</a></li>
            
                <li><a href="../classes/BaseTool.html">BaseTool</a></li>
            
                <li><a href="../classes/BookmarkLink.html">BookmarkLink</a></li>
            
                <li><a href="../classes/Bootstrapper.html">Bootstrapper</a></li>
            
                <li><a href="../classes/Brick.html">Brick</a></li>
            
                <li><a href="../classes/Bricks.html">Bricks</a></li>
            
                <li><a href="../classes/BufferTool.html">BufferTool</a></li>
            
                <li><a href="../classes/ButtonBrick.html">ButtonBrick</a></li>
            
                <li><a href="../classes/Checkbox.html">Checkbox</a></li>
            
                <li><a href="../classes/CheckboxGroup.html">CheckboxGroup</a></li>
            
                <li><a href="../classes/ChoiceBrick.html">ChoiceBrick</a></li>
            
                <li><a href="../classes/ColorPickerBrick.html">ColorPickerBrick</a></li>
            
                <li><a href="../classes/Datagrid.html">Datagrid</a></li>
            
                <li><a href="../classes/DatagridClickHandler.html">DatagridClickHandler</a></li>
            
                <li><a href="../classes/DataLoader.html">DataLoader</a></li>
            
                <li><a href="../classes/DataLoaderGui.html">DataLoaderGui</a></li>
            
                <li><a href="../classes/Decorator.html">Decorator</a></li>
            
                <li><a href="../classes/Dictionary.html">Dictionary</a></li>
            
                <li><a href="../classes/DistanceTool.html">DistanceTool</a></li>
            
                <li><a href="../classes/DropDownBrick.html">DropDownBrick</a></li>
            
                <li><a href="../classes/EventManager.html">EventManager</a></li>
            
                <li><a href="../classes/FeatureClickHandler.html">FeatureClickHandler</a></li>
            
                <li><a href="../classes/FeatureHighlighter.html">FeatureHighlighter</a></li>
            
                <li><a href="../classes/FileInputBrick.html">FileInputBrick</a></li>
            
                <li><a href="../classes/FilterManager.html">FilterManager</a></li>
            
                <li><a href="../classes/FunctionMangler.html">FunctionMangler</a></li>
            
                <li><a href="../classes/GlobalStorage.html">GlobalStorage</a></li>
            
                <li><a href="../classes/GraphicExtension.html">GraphicExtension</a></li>
            
                <li><a href="../classes/GUI.html">GUI</a></li>
            
                <li><a href="../classes/ImageExport.html">ImageExport</a></li>
            
                <li><a href="../classes/LayerGroup.html">LayerGroup</a></li>
            
                <li><a href="../classes/LayerItem.html">LayerItem</a></li>
            
                <li><a href="../classes/LayerLoader.html">LayerLoader</a></li>
            
                <li><a href="../classes/LayoutController.html">LayoutController</a></li>
            
                <li><a href="../classes/Map.html">Map</a></li>
            
                <li><a href="../classes/MapClickHandler.html">MapClickHandler</a></li>
            
                <li><a href="../classes/Maptips.html">Maptips</a></li>
            
                <li><a href="../classes/MultiBrick.html">MultiBrick</a></li>
            
                <li><a href="../classes/Navigation.html">Navigation</a></li>
            
                <li><a href="../classes/OkCancelButtonBrick.html">OkCancelButtonBrick</a></li>
            
                <li><a href="../classes/PopulationTool.html">PopulationTool</a></li>
            
                <li><a href="../classes/Popup.html">Popup</a></li>
            
                <li><a href="../classes/PopupBase.html">PopupBase</a></li>
            
                <li><a href="../classes/PopupBaseSettings.html">PopupBaseSettings</a></li>
            
                <li><a href="../classes/PopupManager.html">PopupManager</a></li>
            
                <li><a href="../classes/Prototype.html">Prototype</a></li>
            
                <li><a href="../classes/QuickZoom.html">QuickZoom</a></li>
            
                <li><a href="../classes/RAMP.html">RAMP</a></li>
            
                <li><a href="../classes/RampMap.html">RampMap</a></li>
            
                <li><a href="../classes/RAMPStarter.html">RAMPStarter</a></li>
            
                <li><a href="../classes/SimpleInputBrick.html">SimpleInputBrick</a></li>
            
                <li><a href="../classes/StepItem.html">StepItem</a></li>
            
                <li><a href="../classes/SubPanel.html">SubPanel</a></li>
            
                <li><a href="../classes/SubPanelSettings.html">SubPanelSettings</a></li>
            
                <li><a href="../classes/Theme.html">Theme</a></li>
            
                <li><a href="../classes/TmplHelper.html">TmplHelper</a></li>
            
                <li><a href="../classes/TmplUtil.html">TmplUtil</a></li>
            
                <li><a href="../classes/Url.html">Url</a></li>
            
                <li><a href="../classes/Util.html">Util</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/BookmarkLink.html">BookmarkLink</a></li>
            
                <li><a href="../modules/Bricks.html">Bricks</a></li>
            
                <li><a href="../modules/Datagrid.html">Datagrid</a></li>
            
                <li><a href="../modules/DataLoader.html">DataLoader</a></li>
            
                <li><a href="../modules/FilterManager.html">FilterManager</a></li>
            
                <li><a href="../modules/GeoSearch.html">GeoSearch</a></li>
            
                <li><a href="../modules/GlobalStorage.html">GlobalStorage</a></li>
            
                <li><a href="../modules/Map.html">Map</a></li>
            
                <li><a href="../modules/Maptips.html">Maptips</a></li>
            
                <li><a href="../modules/Navigation.html">Navigation</a></li>
            
                <li><a href="../modules/QuickZoom.html">QuickZoom</a></li>
            
                <li><a href="../modules/RAMP.html">RAMP</a></li>
            
                <li><a href="../modules/Theme.html">Theme</a></li>
            
                <li><a href="../modules/Tools.html">Tools</a></li>
            
                <li><a href="../modules/UI.html">UI</a></li>
            
                <li><a href="../modules/Utils.html">Utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/js/RAMP/Modules/gui.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿/* global define, $, window, TweenLite, TimelineLite, i18n, console, jQuery, RAMP */
/*jslint white: true */

/**
* UI submodule
*
* @module RAMP
* @submodule UI
* @main UI
*/

/**
* A class for handling most of the GUI on the page.
*
* ####Imports RAMP Modules:
* {{#crossLink &quot;GlobalStorage&quot;}}{{/crossLink}}  
* {{#crossLink &quot;EventManager&quot;}}{{/crossLink}}  
* {{#crossLink &quot;Theme&quot;}}{{/crossLink}}  
* {{#crossLink &quot;Util&quot;}}{{/crossLink}}  
* {{#crossLink &quot;Dictionary&quot;}}{{/crossLink}}  
* {{#crossLink &quot;PopupManager&quot;}}{{/crossLink}}  
* {{#crossLink &quot;TmplHelper&quot;}}{{/crossLink}}  
* 
* ####Uses RAMP Templates:
* {{#crossLink &quot;templates/sub_panel_template.json&quot;}}{{/crossLink}}
* 
* @class GUI
* @static
* @uses dojo/_base/array
* @uses dojo/topic
* @uses dojo/_base/lang
* @uses dojo/Deferred
* @uses dojo/domReady!
* @uses dojo/domReady!
*/
define([
// Dojo
        &quot;dojo/_base/array&quot;, &quot;dojo/topic&quot;, &quot;dojo/_base/lang&quot;, &quot;dojo/Deferred&quot;,

// Ramp
        &quot;ramp/globalStorage&quot;, &quot;ramp/eventManager&quot;,

        &quot;ramp/theme&quot;, &quot;ramp/imageExport&quot;,

// Text
        &quot;dojo/text!./templates/sub_panel_template.json&quot;,

// Util
        &quot;utils/util&quot;, &quot;utils/dictionary&quot;, &quot;utils/popupManager&quot;, &quot;utils/tmplHelper&quot;,

// Dom Ready
        &quot;dojo/domReady!&quot;
],

    function (
    // Dojo
        dojoArray, topic, dojoLang, Deferred,

    // Ramp
        GlobalStorage, EventManager,

        Theme, ImageExport,

    // Text
        subPanelTemplate,

    // Util
        UtilMisc, utilDict, popupManager, TmplHelper) {
        &quot;use strict&quot;;

        var jWindow = $(window),

            sidePanelWbTabs = $(&quot;#panel-div &gt; .wb-tabs&quot;),
            sidePanelTabList = sidePanelWbTabs.find(&quot; &gt; ul[role=tablist]&quot;),
            sidePanelTabPanels = sidePanelWbTabs.find(&quot; &gt; .tabpanels&quot;),

            mapContent = $(&quot;#mapContent&quot;),
            loadIndicator = mapContent.find(&quot;#map-load-indicator&quot;),

            subPanels = {},
            subPanelLoadingAnimation,

        // subPanelAttribute definition

        /**
        * A class holding properties of the SubPanel.
        *
        * @class SubPanelSettings
        * @for SubPanel
        */
            subPanelAttr = {
                /**
                * A name used to identify the subpanel being opened (e.g. &quot;Details&quot;, &quot;Metadata&quot;)
                *
                * @property panelName
                * @for SubPanelSettings
                * @type {String}
                * @default &quot;&quot;
                */

                panelName: &quot;&quot;,
                /**
                * Title of the content to be displayed on the SubPanel (e.g. &quot;CESI Water Quality Indicators&quot;)
                *
                * @property title
                * @type {String}
                * @default &quot;&quot;
                */

                title: &quot;&quot;,
                /**
                * The text inside the subpanel. Can be String or a jQuery object. All nodes sporting CSS class
                * &quot;.shorten-candidate&quot; are treated to the shortening procedure - long strings are curtailed, and [more/less] links are placed at their ends.
                *
                * @property content
                * @type {String | jObject}
                * @default null
                */

                content: null,

                templateKey: &quot;summary_sub_panel_container&quot;,
                /**
                * The node after which the panel will be inserted (e.g. node.find(&quot;.layer-details&quot;)).
                *
                * @property target
                * @type {jObject}
                * @default null
                */

                target: null,
                /**
                * The name of the module that requested to open the SubPanel (e.g. &quot;filterManager&quot;). Used for identification of the panel&#x27;s loyalty.
                *
                * @property origin
                * @type {String}
                * @default &quot;&quot;
                */

                origin: &quot;&quot;,
                /**
                * A unique id of the SubPanel. If none provided, a random one is generated. It is used to determine the animation and update function
                * to run on content update.
                *
                * @property guid
                * @type {String}
                * @default &quot;&quot;
                */

                guid: &quot;&quot;,
                /**
                * Indicates that the open SubPanel request is a content update to the already opened SubPanel.
                * Does not trigger any of the &#x60;doOn-&#x60; or &#x60;doAfter-&#x60; functions.
                *
                * __Use case:__ the uses clicks on the metadata button.
                * 1. A request to open a SubPanel is sent with only the title since the metadata content is not yet available
                * 2. Metadata is fetched from the server
                * 3. A second request to open a SubPanel is sent having &#x60;update&#x60; set to &#x60;true&#x60; and featuring the __same__ &#x60;guid&#x60; as the first request
                * 4. Only the content of the SubPanel is updated; no extra animations are triggered
                *
                * @property update
                * @type {Boolean}
                * @default false
                */

                update: false,
                /**
                * The callback function when the panel starts the opening animation; also triggered by updating panel content; can be triggered many times.
                *
                * @property doOnOpen
                * @type {Function}
                * @default null
                */

                doOnOpen: null,
                /**
                * The callback function when the panel finishes the opening animation; also triggered by updating panel content; can be triggered many times.
                *
                * @property doAfterOpen
                * @type {Function}
                * @default null
                */

                doAfterOpen: null,
                /**
                * The callback function when the panel starts the closing animation; also triggered by updating panel content; can be triggered many times.
                *
                * @property doOnHide
                * @type {Function}
                * @default null
                */

                doOnHide: null,
                /**
                * The callback function when the panel becomes hidden; also triggered by updating panel content; can be triggered many times.
                *
                * @property doAfterHide
                * @type {Function}
                * @default null
                */

                doAfterHide: null,
                /**
                * The callback function when the panel is completely closed, its nodes destroyed; can be triggered only once in a lifespan of the panel.
                *
                * @property doOnDestroy
                * @type {Function}
                * @default null
                */

                doOnDestroy: null,
                /**
                * The callback function executed after the SubPanel content is updated.
                * __Doesn&#x27;t work correctly yet.__
                *
                * @property doAfterUpdate
                * @type {Function}
                * @default null
                */

                doAfterUpdate: null,
                /**
                * The target number of chars after which a content text node will be shortened.
                *
                * @property showChars
                * @type {Number}
                * @default 170
                */

                showChars: 170
            },

        // Panel Prototype

        /**
        * [subPanelPrototype description]
        *
        * @class SubPanel
        * @constructor
        * @for GUI
        */
            subPanelPrototype = {
                /**
                * Indicates if the closing animation is under way.
                *
                * @property _closing
                * @private
                * @for SubPanel
                * @type {Boolean}
                * @default false
                */

                _closing: false,
                /**
                * Holds a deferred that would destroy the panel after the closing animation completes. May be interrupted.
                *
                * @property _destroyDeferred
                * @type {Deferred}
                * @private
                * @default null
                */

                _destroyDeferred: null,
                /**
                * SubPanel attributes
                *
                * @property _attr
                * @private
                * @default null
                * @type {SubPanelSettings}
                */

                _attr: null,
                /**
                * Indicates if the SubPanel is visible at the moment. Doesn&#x27;t make the panel visible or invisible, just prevents animations on the content
                * to run when it is set to &#x60;true&#x60;.
                *
                * @property _visible
                * @private
                * @default false
                * @type {Boolean}
                */

                _visible: false,
                /**
                * The outermost &#x60;div&#x60; of the SubPanel.
                *
                * @property container
                * @default null
                * @type {jObject}
                */

                container: null,
                /**
                * The inner &#x60;div&#x60; of the SubPanel. Closing and opening animations are run on this &#x60;div&#x60;.
                *
                * @property panel
                * @default null
                * @type {jQobject}
                */

                panel: null,
                /**
                * &#x60;div&#x60; housing the content of the SubPanel, including its title.
                *
                * @property _subPanelContentDiv
                * @private
                * @default null
                * @type {jObject}
                */

                _subPanelContentDiv: null,
                /**
                * Heading of the content in the SubPanel.
                *
                * @property _panelTitle
                * @private
                * @default null
                * @type {jObject}
                */

                _panelTitle: null,
                /**
                * &#x60;div&#x60; housing the content of the SubPanel, excluding its title.
                *
                * @property _panelContentDiv
                * @private
                * @default null
                * @type {jObject}
                */

                _panelContentDiv: null,
                /**
                * Default duration of the SubPanel animation in milliseconds.
                *
                * @property _animatePanelDuration
                * @private
                * @default 0.5
                * @type {Number}
                */

                _animatePanelDuration: 0.5, //0.4,

                timeLine: null,

                /**
                * Apply the shortening plugin to the panel data
                *
                * @method parseContent
                * @param  {jObject} data Content to be shortened
                * @return {jObject} Content with after shortening long text nodes
                */
                parseContent: function (data) {
                    //console.log(this._attr.showChars, jQuery.type(data), data);
                    return (jQuery.type(data) === &quot;object&quot; ? data : $(data))
                        .find(&quot;.shorten-candidate&quot;).shorten({
                            showChars: this._attr.showChars
                        })
                        .removeClass(&quot;shorten-candidate&quot;).end();
                },
                /**
                * Returns this SubPanel&#x27;s settings object.
                *
                * @method getAttributes
                * @return {SubPanelSettings} This SubPanel&#x27;s settings
                */
                getAttributes: function () {
                    return this._attr;
                },
                /**
                * Returns this SubPanel&#x27;s container &#x60;div&#x60;.
                *
                * @method getContainer
                * @return {jObject} This SubPanel&#x27;s &#x60;div&#x60;
                */
                getContainer: function () {
                    return this.container;
                },
                /**
                * Returns the inner &#x60;div&#x60; of the SubPanel
                *
                * @method getPanel
                * @return {jObject} The inner &#x60;div&#x60; of the SubPanel
                */
                getPanel: function () {
                    return this.panel;
                },
                /**
                * Returns the &#x60;origin&#x60; of this SubPanel.
                *
                * @method getOrigin
                * @return {String} The &#x60;origin&#x60; of this SubPanel
                */
                getOrigin: function () {
                    return this._attr.origin;
                },
                /**
                * Returns the &#x60;guid&#x60; of this SubPanel.
                *
                * @method getOrigin
                * @return {String} The &#x60;guid&#x60; of this SubPanel
                */
                getGuid: function () {
                    return this._attr.guid;
                },
                /**
                * Destroys this SubPanel.
                *
                * @method destroy
                * @param  {Number} speed    The duration of the animation in milliseconds
                * @param  {Deferred} deferred The deferred to be resolved after the SubPanel is destroyed
                */
                destroy: function (speed, deferred) {
                    if (this._attr.doOnHide) {
                        this._attr.doOnHide();
                    }

                    this._closing = true;
                    this._destroyDeferred = deferred;

                    // remove CSS animation class to prevent flickering
                    this._subPanelContentDiv.find(&quot;.fadeInDown&quot;).removeClass(&quot;fadeInDown&quot;);

                    //sidePanel.getContainer().after(this.container);
                    layoutController.getPanelContainer().before(this.container);
                    //adjutSubPanelDimensions(this);

                    layoutController.subPanelChange(false, this._attr.origin, this.container, false);

                    // do after closing animation completes
                    this.timeLine.eventCallback(&quot;onReverseComplete&quot;,
                        function () {
                            if (this._attr.doAfterHide) {
                                this._attr.doAfterHide();
                            }
                            if (this._attr.doOnDestroy) {
                                this._attr.doOnDestroy();
                            }
                            this._visible = false;
                            layoutController.subPanelChange(false, this._attr.origin, null, true);

                            this.container.remove();

                            if (deferred) {
                                deferred.resolve(true);
                            }
                        }, [], this);

                    this.timeLine.reverse();
                },

                /**
                * Reopens the SubPanel - stops the closing animation and initiates the opening animation.
                *
                * @method reopen
                */
                reopen: function () {
                    //this.panel.stop();
                    this.timeLine.pause();
                    this._closing = false;
                    if (this._destroyDeferred) {
                        this._destroyDeferred.cancel();
                        this._destroyDeferred = null;
                    }

                    this.open();
                },

                /**
                * Opens the SubPanel. Sends out &#x60;EventManager.GUI.SUBPANEL_CHANGE&#x60; event.
                *
                * @method open
                */
                open: function () {
                    if (this._attr.doOnOpen) {
                        this._attr.doOnOpen();
                    }
                    this._visible = true;
                    layoutController.subPanelChange(true, this._attr.origin, this.container, false);

                    this.timeLine.play();
                },

                /**
                * Assigns a new origin to the SubPanel.
                *
                * @method changeOrigin
                * @param  {String} newOrigin The new origin of the SubPanel.
                */
                changeOrigin: function (newOrigin) {
                    this._attr.origin = newOrigin;
                },

                /**
                * Shifts the SubPanel to the new node in the DOM.
                *
                * @method shiftTarget
                * @param  {jObject} newTarget A node in the DOM to shift the SubPanel to
                */
                shiftTarget: function (newTarget) {
                    if (this._attr.target !== newTarget) {
                        // remove animation class to prevent flickering of data
                        this._subPanelContentDiv.find(&quot;.fadeInDown&quot;).removeClass(&quot;fadeInDown&quot;);
                        newTarget.after(this.container);
                        this._attr.target = newTarget;
                    }
                },

                /**
                * Creates a new instance of SubPanel.
                *
                * @method create
                * @param  {SubPanelSettings} a Settings for the SubPanel
                */
                create: function (a) {
                    var //subPanelContent,
                        subPanelString,
                        parsedContent;

                    console.log(&quot;create panel, &quot;, a.origin);

                    a.guid = a.guid || UtilMisc.guid();

                    dojoLang.mixin(this._attr, a);

                    subPanelString = TmplHelper.template(this._attr.templateKey,
                        dojoLang.mixin(
                            this._attr,
                            {
                                closeTitle: i18n.t(&#x27;gui.actions.close&#x27;)
                            }
                        ),
                        subPanelTemplate);

                    this.container = $(subPanelString).insertAfter(this._attr.target);
                    this.panel = this.container.find(&quot;.sub-panel&quot;);

                    this._subPanelContentDiv = this.panel.find(&quot;.sub-panel-content&quot;);
                    this._panelTitle = this.panel.find(&quot;.panel-title&quot;);
                    this._panelContentDiv = this.panel.find(&quot;.panel-content-div&quot;);

                    // set panel content
                    parsedContent = this.parseContent(this._attr.content);
                    this._panelContentDiv.empty().append(parsedContent);

                    this.timeLine = new TimelineLite(
                        {
                            paused: true,
                            onComplete: function () {
                                if (this._attr.doAfterOpen) {
                                    this._attr.doAfterOpen();
                                }

                                layoutController.subPanelChange(true, this._attr.origin, this.container, true);
                            },
                            onCompleteScope: this
                        })
                        .to(this.panel, this._animatePanelDuration, { left: 0, ease: &quot;easeOutCirc&quot; })
                        .to(loadIndicator, this._animatePanelDuration, { right: this.panel.width() + 6, ease: &quot;easeOutCirc&quot; }, 0); // 6 is double border width

                    Theme.tooltipster(this.container);

                    this.update(this._attr);
                },

                /**
                * Performs an update of the content and title of the SubPanel, running appropriate animation and &#x60;doOn-&#x60; / &#x60;doAfter-&#x60; functions.
                *
                * @method update
                * @param  {SubPanelSettings} a New settings for the SubPanel
                */
                update: function (a) {
                    // helper functions
                    var animateContentDuration = 300,

                        updateDefered = [new Deferred(), new Deferred()],

                        animateContent = function (node, newData, d) {
                            if (newData) {
                                node.addClass(&#x27;animated fadeOutDown&#x27;);
                                window.setTimeout(dojoLang.hitch(this,
                                        function () {
                                            node
                                            //.html(newData)
                                            .empty().append(newData)
                                                .removeClass(&quot;fadeOutDown&quot;)
                                                .addClass(&#x27;animated fadeInDown&#x27;); //.find(&quot;.shorten-candidate&quot;).shorten();

                                            d.resolve();
                                        }),
                                    animateContentDuration);
                            }
                        },

                        setContent = function (node, oldData, newData, parsedData, visible, d) {
                            newData = (newData === null) ? parsedData = subPanelLoadingAnimation : newData;
                            if (newData) {
                                if (newData !== oldData) {
                                    if (visible) {
                                        //ideally, need to wait until the animation completes before proceeding?
                                        animateContent(node, parsedData, d);
                                    } else {
                                        node.empty().append(parsedData);
                                        d.resolve();
                                    }
                                } else {
                                    d.resolve();
                                }
                            } else {
                                d.resolve();
                            }
                        },

                        updateContent = dojoLang.hitch(this,
                            function (a) {
                                // if the content in the subpanel is scrolled down, scroll back to the top
                                TweenLite.to(this._subPanelContentDiv, animateContentDuration / 1000,
                                    { scrollTop: 0, ease: &quot;easeOutCirc&quot; });

                                setContent(this._panelTitle, this._attr.title, a.title, a.title, this._visible, updateDefered[0]);
                                setContent(this._panelContentDiv, this._attr.content, a.content, this.parseContent(a.content), this._visible, updateDefered[1]);

                                dojoLang.mixin(this._attr, a);
                            }
                        );

                    // doAfterUpdate should be called AFTER update (animation) completes...
                    UtilMisc.afterAll(updateDefered, function () {
                        if (a.doAfterUpdate) {
                            a.doAfterUpdate();
                        }
                    });

                    // panel is closing; new data is not an update
                    if (this._closing &amp;&amp; !a.update) {
                        //
                        if (this._attr.guid !== a.guid) {
                            if (this._attr.doOnHide) {
                                this._attr.doOnHide();
                            }
                            if (this._attr.doAfterHide) {
                                this._attr.doAfterHide();
                            }

                            // move panel to the new target
                            a.target.after(this.container);
                            updateContent(a);
                        }

                        this.reopen();

                        // panel is not closing
                    } else if (!this._closing) {
                        // data is not an update
                        if (!a.update &amp;&amp; this._attr.guid !== a.guid) {
                            if (this._attr.doOnHide) {
                                this._attr.doOnHide();
                            }
                            if (this._attr.doAfterHide) {
                                this._attr.doAfterHide();
                            }

                            // move panel to the new target
                            a.target.after(this.container);
                            updateContent(a);

                            if (a.doOnOpen) {
                                a.doOnOpen();
                            }
                            if (a.doAfterOpen) {
                                a.doAfterOpen();
                            }
                        }

                        // guid is the same - data can update or not (should be an update)
                        //if (a.update &amp;&amp; attr.guid === a.guid) {
                        if (this._attr.guid === a.guid) {
                            updateContent(a);
                        }
                    }
                }
            },

            helpToggle = $(&quot;#helpToggle&quot;),
            helpSectionContainer = $(&quot;#help-section-container&quot;),
            helpSection = $(&quot;#help-section&quot;),

            addLayerToggle = $(&quot;#addLayer-toggle&quot;),
            addLayerSectionContainer = $(&quot;#addLayer-section-container&quot;),
            //AddLayerSection = $(&quot;#addLayer-section&quot;),

            wmsToggle = $(&quot;#uglyGetFiToggle&quot;),

            cssButtonPressedClass = &quot;button-pressed&quot;,
            cssExpandedClass = &quot;state-expanded&quot;,

            helpPanelPopup,
            addLayerPanelPopup,
            wmsQueryPopup,

            transitionDuration = 0.5,

            layoutController;

        /**
        * Controls layout transition such as full-data and full-screen modes, opening and closing of the side panel, adjusts layout when resizing the browser window.
        *
        * @class LayoutController
        * @static
        * @for GUI
        */
        layoutController = (function () {
            var viewport = $(&quot;.viewport&quot;),
                mapDiv = $(&quot;#map-div&quot;),
                mapContent = $(&quot;#mapContent&quot;),
                fullScreenToggle = $(&quot;#fullScreenToggle&quot;),
                fullScreenPopup,

                mapToolbar = $(&quot;#map-toolbar&quot;),
                basemapControls = $(&quot;#basemapControls&quot;),

                panelDiv = $(&quot;#panel-div&quot;),
                panelToggle = $(&quot;#panel-toggle&quot;),
                panelPopup,
                panelWidthDefault, // default width of the SidePanel.
                layoutWidthThreshold = 1200, // minimum width of the wide layout

                windowWidth,

                layoutChange,

                _isFullData = false,
                fullDataTimeLine = new TimelineLite({
                    paused: true,
                    onComplete: function () {
                        adjustHeight();
                        layoutChange();

                        // set tooltips on the collapsed toolbar
                        mapToolbar
                            .find(&quot;.map-toolbar-item-button:visible&quot;)
                            .map(function (i, node) {
                                node = $(node);
                                node
                                    .addClass(&quot;_tooltip tooltip-temp&quot;)
                                    .attr(
                                        &quot;title&quot;,
                                        node.find(&quot;span&quot;).text()
                                    );
                            });

                        Theme.tooltipster(mapToolbar);

                        //console.log(&quot;finished&quot;, EventManager.Datagrid.APPLY_EXTENT_FILTER);
                        //topic.publish(EventManager.Datagrid.APPLY_EXTENT_FILTER);

                        // kill key events to stop tab switching when the other tab is hidden
                        panelDiv.on(&quot;keydown&quot;, &quot;.wb-tabs &gt; ul &gt; li &gt; a&quot;, stopEventPropagation);
                    },
                    onReverseComplete: function () {
                        viewport.removeClass(&quot;full-data-mode&quot;);

                        adjustHeight();
                        layoutChange();

                        // remove tooltips from the restored toolbar and only from the buttons with a temporary tooltip
                        Theme.tooltipster(
                            mapToolbar
                                .find(&quot;.map-toolbar-item-button.tooltip-temp&quot;)
                                .parent(),
                            null, &quot;destroy&quot;);

                        mapToolbar
                            .find(&quot;.map-toolbar-item-button.tooltip-temp&quot;)
                            .removeClass(&quot;_tooltip&quot;)
                            .removeAttr(&quot;title&quot;);

                        //console.log(&quot;reverse finished&quot;, EventManager.Datagrid.APPLY_EXTENT_FILTER);
                        //topic.publish(EventManager.Datagrid.APPLY_EXTENT_FILTER);
                        // restore key events
                        panelDiv.off(&quot;keydown&quot;, &quot;.wb-tabs &gt; ul &gt; li &gt; a&quot;, stopEventPropagation);
                    }
                }),
                panelToggleTimeLine = new TimelineLite({ paused: true }),
                fullDataSubpanelChangeTimeLine = new TimelineLite({ paused: true }),
                noDataTimeLine = new TimelineLite({
                    paused: true,
                    onComplete: function () {
                        // kill key events to stop tab switching when the other tab is hidden
                        panelDiv.on(&quot;keydown&quot;, &quot;.wb-tabs &gt; ul &gt; li &gt; a&quot;, stopEventPropagation);
                    },
                    onReverseComplete: function () {
                        // restore key events
                        panelDiv.off(&quot;keydown&quot;, &quot;.wb-tabs &gt; ul &gt; li &gt; a&quot;, stopEventPropagation);
                    }
                }),

                // timeline generating functions
                createFullDataTL,
                createPanelToggleTL,
                createFullDataSubpanelChangeTL,

                timeLines;

            createFullDataTL = function () {
                if (panelDiv.find(&quot;.wb-tabs &gt; ul li&quot;).length === 0) {
                    return;
                }

                fullDataTimeLine
                    .fromTo(mapDiv, transitionDuration, { width: &quot;auto&quot; }, { width: 35, ease: &quot;easeOutCirc&quot; }, 0)

                    .fromTo(mapContent, transitionDuration, { opacity: 1 }, { opacity: 0, ease: &quot;easeOutCirc&quot; }, 0)
                    .set(mapContent, { top: &quot;500px&quot; })

                    .to(panelToggle, transitionDuration, { right: -13, ease: &quot;easeOutCirc&quot; }, 0)
                    .set(panelToggle, { display: &quot;none&quot; })

                    .to(basemapControls, transitionDuration / 2, { opacity: 0, ease: &quot;easeOutCirc&quot; }, 0)
                    .to(basemapControls, 0, { display: &quot;none&quot; }, transitionDuration / 2)
                    .fromTo(mapToolbar, transitionDuration / 2,
                        { width: &quot;100%&quot;, height: &quot;32px&quot; },
                        { width: &quot;32px&quot;, height: $(&quot;#map-div&quot;).height(), ease: &quot;easeOutCirc&quot; }, transitionDuration / 2)

                    .to(mapToolbar.find(&quot;.map-toolbar-item-button span&quot;), transitionDuration / 2, { width: 0, ease: &quot;easeOutCirc&quot; }, 0)
                    .set(mapToolbar.find(&quot;.map-toolbar-item-button span&quot;), { display: &quot;none&quot; }, transitionDuration / 2)

                    .fromTo(panelDiv.find(&quot;.wb-tabs &gt; ul li:first&quot;), transitionDuration, { width: &quot;50%&quot; }, { width: &quot;0%&quot;, display: &quot;none&quot;, ease: &quot;easeOutCirc&quot; }, 0)
                    .fromTo(panelDiv.find(&quot;.wb-tabs &gt; ul li:last&quot;), transitionDuration, { width: &quot;50%&quot; }, { width: &quot;100%&quot;, className: &quot;+=h5&quot;, ease: &quot;easeOutCirc&quot; }, 0)

                    .fromTo(panelDiv, transitionDuration,
                        { width: panelWidthDefault, left: &quot;auto&quot; },
                        { left: 35, width: &quot;auto&quot;, ease: &quot;easeOutCirc&quot; }, 0);
            };

            createPanelToggleTL = function () {
                panelToggleTimeLine
                    .fromTo(panelDiv, transitionDuration, { right: 0 }, { right: -panelWidthDefault, ease: &quot;easeOutCirc&quot; }, 0)
                    .set(panelDiv, { display: &quot;none&quot; }, transitionDuration)

                    .fromTo(mapDiv, transitionDuration, { right: panelWidthDefault }, { right: 0, ease: &quot;easeOutCirc&quot; }, 0);
            };

            createFullDataSubpanelChangeTL = function () {
                fullDataSubpanelChangeTimeLine
                    .fromTo(panelDiv, transitionDuration,
                        { right: 0 },
                        { right: panelWidthDefault, ease: &quot;easeOutCirc&quot; });
            };

            timeLines = [
                {
                    timeLine: fullDataTimeLine,
                    generator: createFullDataTL
                },
                {
                    timeLine: panelToggleTimeLine,
                    generator: createPanelToggleTL
                },
                {
                    timeLine: fullDataSubpanelChangeTimeLine,
                    generator: createFullDataSubpanelChangeTL
                }
            ];

            // timeline that hides Data tab
            noDataTimeLine
                .fromTo(panelDiv.find(&quot;.wb-tabs &gt; ul li:first&quot;), transitionDuration, { width: &quot;50%&quot; }, { width: &quot;100%&quot;, className: &quot;+=h5&quot;, ease: &quot;easeOutCirc&quot; }, 0)
                .to(panelDiv.find(&quot;.wb-tabs &gt; ul li:first&quot;), transitionDuration, { lineHeight: &#x27;20px&#x27; }, 0)
                .fromTo(panelDiv.find(&quot;.wb-tabs &gt; ul li:last&quot;), transitionDuration, { width: &quot;50%&quot; }, { width: &quot;0%&quot;, display: &quot;none&quot;, ease: &quot;easeOutCirc&quot; }, 0)
            ;

            /**
            * Fires an event when the layout of the page changes.
            *
            * @method layoutChange
            * @private
            * @for LayoutController
            */
            layoutChange = function () {
                if (!_isFullData) {
                    console.log(&quot;GUI --&gt; EventManager.GUI.LAYOUT_CHANGE&quot;);
                    topic.publish(EventManager.GUI.LAYOUT_CHANGE);
                }
            };

            /**
            * Adjusts the height of the help section based on the height of the window.
            *
            * @method adjustHeight
            * @private
            */
            function adjustHeight() {
                helpSection.css({
                    &quot;max-height&quot;: jWindow.height() - (_isFullData ? jWindow.height() * 0.2 : mapToolbar.offset().top) - 90 // 90 is an arbitrary-wide gap between the help panel and the upper toolbar
                });
            }

            /**
            * Executed after full-screen mode transition is complete.
            *
            * @method onFullScreenComplete
            * @private
            */
            function onFullScreenComplete() {
                adjustHeight();
                layoutChange();

                topic.publish(EventManager.GUI.FULLSCREEN_CHANGE, {
                    visible: Theme.isFullScreen()
                });
            }

            /**
            * Publishes &#x60;PANEL_CHANGE&#x60; event when the visibility of the SidePanel changes.
            *
            * @method panelChange
            * @param  {Boolean} visible Indicates whether the SidePanel is visible or not
            * @private
            */
            function panelChange(visible) {
                topic.publish(EventManager.GUI.PANEL_CHANGE, {
                    visible: visible
                });
            }

            /**
            * Slides the SidePanel open.
            *
            * @method openPanel
            * @private
            * @param  {Deferred} d A deferred to be resolved upon completion of the animation
            */
            function openPanel(d) {
                /*jshint validthis: true */
                panelToggleTimeLine.eventCallback(&quot;onReverseComplete&quot;,
                        function () {
                            layoutChange();
                            panelChange(true);

                            // update close button tooltips
                            panelToggle
                                .tooltipster(&quot;content&quot;, i18n.t(&quot;gui.actions.close&quot;))
                                .find(&quot;span.wb-invisible&quot;).text(i18n.t(&quot;gui.actions.close&quot;));

                            d.resolve();
                        }, [], this);

                viewport.removeClass(&quot;no-sidepanel-mode&quot;);
                panelToggleTimeLine.reverse();
            }

            /**
            * Slide the SidePanel close
            *
            * @method closePanel
            * @private
            * @param  {Deferred} d A deferred to be resolved upon completion of the animation
            */
            function closePanel(d) {
                /*jshint validthis: true */
                panelToggleTimeLine.eventCallback(&quot;onComplete&quot;,
                        function () {
                            console.log(&quot;GUI &lt;-- map/update-end from gui&quot;);
                            layoutChange();
                            panelChange(false);

                            // update open button tooltips
                            panelToggle
                                .tooltipster(&quot;content&quot;, i18n.t(&quot;gui.actions.open&quot;))
                                .find(&quot;span.wb-invisible&quot;).text(i18n.t(&quot;gui.actions.open&quot;));

                            viewport.addClass(&quot;no-sidepanel-mode&quot;);

                            d.resolve();
                        }, [], this);

                panelToggleTimeLine.play();
            }

            /**
            * Toggles the full-data mode on and off.
            *
            * @method _toggleFullDataMode
            * @param {Boolean} [fullData] if true, switches to full-data mode; if false, switches to summary mode; if undefined, toggle mode based on the current state
            * @private
            */
            function _toggleFullDataMode(fullData) {
                _isFullData = typeof fullData === &#x27;boolean&#x27; ? fullData : !_isFullData;

                // if the timeline duration is 0, reset it
                // it&#x27;s to work-around IE bug where it&#x27;s so slow, it can&#x27;t pick up nodes created by WET scripts when creating timelines
                if (fullDataTimeLine.totalDuration() === 0) {
                    UtilMisc.resetTimelines([timeLines[0]]);
                }

                if (_isFullData) {
                    viewport.addClass(&quot;full-data-mode&quot;); // set full-data-mode css class BEFORE animation; remove it after it finishes - on onReverseComplete callback
                    fullDataTimeLine.play();
                } else {
                    fullDataSubpanelChangeTimeLine.reverse(); // play this animation to readjust the sidepanel if the details panel was opened and not closed in full data mode
                    fullDataTimeLine.reverse();
                }

                // close subpanels
                utilDict.forEachEntry(subPanels, function (key) {
                    hideSubPanel({
                        origin: key
                    });
                });
            }

            /**
            * Changes internal panel width reference based on the window width.
            *
            * @method updatePanelWidth
            * @private
            */
            function updatePanelWidth() {
                panelWidthDefault = windowWidth &lt; layoutWidthThreshold ? 340 : 430;
            }

            /**
            * Optimizes layout based on the window width
            *
            * @method optimizeLayout
            * @private
            */
            function optimizeLayout() {
                if ((windowWidth &lt; layoutWidthThreshold &amp;&amp; jWindow.width() &gt; layoutWidthThreshold) ||
                    (windowWidth &gt; layoutWidthThreshold &amp;&amp; jWindow.width() &lt; layoutWidthThreshold)) {
                    windowWidth = jWindow.width();
                    updatePanelWidth();

                    UtilMisc.resetTimelines(timeLines, true);
                }
            }

            return {
                /**
                * Initializes layout controller.
                *
                * @method init
                */
                init: function () {
                    windowWidth = jWindow.width();
                    jWindow.on(&quot;resize&quot;, optimizeLayout);
                    updatePanelWidth();

                    UtilMisc.resetTimelines(timeLines);

                    Theme
                        .fullScreenCallback(&quot;onComplete&quot;, onFullScreenComplete)
                        .fullScreenCallback(&quot;onReverseComplete&quot;, onFullScreenComplete);

                    // initialize the panel popup
                    panelPopup = popupManager.registerPopup(panelToggle, &quot;click&quot;,
                        openPanel, {
                            activeClass: cssExpandedClass,
                            closeHandler: closePanel
                        }
                    );

                    // set listener to the panel toggle
                    topic.subscribe(EventManager.GUI.PANEL_TOGGLE, function (event) {
                        panelPopup.toggle(null, event.visible);
                    });

                    if (!RAMP.config.ui.mapQueryToggle.show) {
                        RAMP.state.ui.wmsQuery = false;
                        wmsToggle.remove();
                    }

                    // set listener to the full-screen toggle
                    fullScreenPopup = popupManager.registerPopup(fullScreenToggle, &quot;click&quot;,
                        function (d) {
                            Theme.toggleFullScreenMode();
                            d.resolve();
                        }, {
                            activeClass: &quot;button-pressed&quot;,
                            setClassBefore: true
                        }
                    );

                    // if the vertical space is too small, trigger the full-screen
                    if (mapContent.height() &lt; jWindow.height() * 0.6) {
                        fullScreenPopup.open();
                    }

                    adjustHeight();
                },

                /**
                * Toggles the FullScreen mode of the application
                *
                * @method toggleFullScreenMode
                * @param  {Boolean} fullscreen true - expand; false - collapse; undefined - toggle;
                */
                toggleFullScreenMode: function (fullscreen) {
                    fullScreenPopup.toggle(null, fullscreen);
                },

                /**
                 * Toggles the visibility of Data tab in the side panel
                 * 
                 * @method toggleDataTab
                 * @param  {Boolean} open true - show; false - hide;
                 */
                toggleDataTab: function (open) {
                    if (open) {
                        noDataTimeLine.reverse();
                    } else {
                        noDataTimeLine.play();
                    }
                },

                /**
                * Returns the state of the full-data mode.
                *
                * @method isFullData
                * @return {Boolean} True is full-data mode on; false otherwise
                */
                isFullData: function () {
                    return _isFullData;
                },

                /**
                * Toggles the full-data mode on and off.
                *
                * @method toggleFullDataMode
                * @param {Boolean} [fullData] if true, switches to full-data mode; if false, switches to summary mode; if undefined, toggle mode based on the current state
                */
                toggleFullDataMode: function (fullData) {
                    _toggleFullDataMode(fullData);
                },

                /**
                * Fires an event when the subpanel closes or opens.
                *
                * @method subPanelChange
                * @param {Boolean} visible indicates whether the subpanel is visible or not (the panel is considered invisible when it&#x27;s being destroyed, starts closing)
                * @param {String} origin origin of the subpanel
                * @param {JObject} container subpanel container
                * @param {Boolean} isComplete indicates if subPanel transition has completed or just started
                */
                subPanelChange: function (visible, origin, container, isComplete) {
                    // check if the fullData transition is already underway
                    if (!fullDataTimeLine.isActive() &amp;&amp; _isFullData &amp;&amp; !isComplete) {
                        // adjust the sidePanel position shifting the right edge to the left, making space for the subpanel to open at
                        if (visible) {
                            fullDataSubpanelChangeTimeLine.play();
                        } else if (!visible) {
                            fullDataSubpanelChangeTimeLine.reverse();
                        }
                    }

                    // hide the sidepanel toggle when a subpanel is opened to prevent the user from closing sidepanel with subpanel still opened
                    if (!isComplete) {
                        if (visible) {
                            panelToggle.hide();
                        } else {
                            panelToggle.show();
                        }
                    }

                    topic.publish(EventManager.GUI.SUBPANEL_CHANGE, {
                        visible: visible,
                        origin: origin,
                        container: container,
                        offsetLeft: (container) ? container.width() + 25 + layoutController.getPanelWidth() : layoutController.getPanelWidth(),
                        isComplete: isComplete
                    });
                },

                /**
                * Returns the outer most &#x60;div&#x60; of this SidePanel.
                *
                * @method getContainer
                * @return {jObject} The outer most &#x60;div&#x60; of this SidePanel
                */
                getPanelContainer: function () {
                    return panelDiv;
                },

                /**
                * Gets the width of this SidePanel.
                *
                * @method width
                * @return {Number} The width of this SidePanel
                * @for LayoutController
                */
                getPanelWidth: function () {
                    return panelDiv.filter(&quot;:visible&quot;).width();
                }
            };
        }());

        /**
        * Create a new SubPanel with the settings provided.
        *
        * @private
        * @method newSubPanel
        * @param  {SubPanelSettings} attr SubPanel settings
        * @return {SubPanel}      A newly created SubPanel
        * @for GUI
        */
        function newSubPanel(attr) {
            var subPanel = Object.create(subPanelPrototype);
            subPanel._attr = Object.create(subPanelAttr);
            subPanel.create(attr);
            //adjutSubPanelDimensions(subPanel);

            return subPanel;
        }

        /**
        * Creates and opens a new SubPanel with given settings.
        * If the SubPanel with the requested &#x60;origin&#x60; is already present, updates its content.
        *
        * @method showSubPanel
        * @private
        * @param  {SubPanelSettings} attr Settings for the SubPanel instance
        */
        function showSubPanel(attr) {
            var deferred = new Deferred(),
                subPanel;

            deferred.then(function () {
                attr = subPanel.getAttributes();
                subPanel = subPanels[attr.origin];

                subPanel.open();
                subPanel.getPanel().find(&quot;.sub-panel-toggle&quot;)
                    .on(&quot;click&quot;, dojoLang.hitch(this, function () {
                        hideSubPanel(attr);

                        // reset focus back to link where the subpanel was created from
                        if (attr.target.selector !== &quot;#map-div&quot;) {
                            $(attr.target).find(&quot;:tabbable&quot;).first().focus();
                        }
                    }));
            });

            // take over the panel spawned by other components
            if (attr.consumeOrigin &amp;&amp; subPanels[attr.consumeOrigin]) {
                subPanel = subPanels[attr.consumeOrigin];
                subPanel.changeOrigin(attr.origin);
                subPanel.shiftTarget(attr.target);

                delete subPanels[attr.consumeOrigin];
                subPanels[attr.origin] = subPanel;
            }

            if (subPanels[attr.origin]) {
                // if the panel exists, just update it
                subPanels[attr.origin].update(attr);
            } else if (!attr.update) {
                // create if doesn&#x27;t
                subPanel = newSubPanel(attr);
                subPanels[attr.origin] = subPanel;

                // close all other panels; and open the newly created one after all others are closed
                UtilMisc.executeOnDone(subPanels,
                    function (p, d) {
                        if (p &amp;&amp; p.getOrigin() !== attr.origin) {
                            hideSubPanel({
                                origin: p.getOrigin()
                            }, 200, d);
                        } else {
                            d.resolve(true);
                        }
                    },
                    deferred);
            }
        }

        /**
        * Closes the SubPanel whose &#x60;origin&#x60; is specified in the &#x60;attr&#x60; parameter.
        *
        * @method hideSubPanel
        * @private
        * @param  {SubPanelSettings} attr  only &#x60;origin&#x60; attribute is required here
        * @param  {Number} speed Duration of the closing animation
        * @param  {Deferred} d     The deferred object to be resolved upon successful closing of the panel
        */
        function hideSubPanel(attr, speed, d) {
            var deferred = new Deferred(function () {
                if (d) {
                    d.cancel();
                }
            });

            deferred.then(function () {
                // remove the panel from the object after it closes
                delete subPanels[attr.origin]; // more on delete: http://perfectionkills.com/understanding-delete/
                if (d) {
                    d.resolve(true);
                }
            });

            if (subPanels[attr.origin]) {
                subPanels[attr.origin].destroy(speed, deferred);
            }
        }

        /**
        * Moves the SubPanel with the specified &#x60;origin&#x60; in the DOM hierarchy to the new specified &#x60;target&#x60;; if &#x60;target&#x60; is not specified, the SubPanel is attached to the SidePanel.
        *
        * @method dockSubPanel
        * @private
        * @param  {SubPanelSettings} attr Settings for the SubPanel; only &#x60;target&#x60; and &#x60;origin&#x60; are required here
        */
        function dockSubPanel(attr) {
            var target = attr.target || layoutController.getPanelContainer(),
                subPanel = subPanels[attr.origin];

            if (subPanel) {
                //console.log(&quot;docking subpanel&quot;);
                subPanel.shiftTarget(target);
            }
        }

        /**
        * Finds a SubPanel with &#x60;origin&#x60; equal to the supplied &#x60;consumeOrigin&#x60; and
        * + changes its &#x60;origin&#x60; to the supplied &#x60;origin&#x60;
        * + moves the SubPanel in the DOM hierarchy and attaches it to the specified target
        *
        * @method captureSubPanel
        * @private
        * @param  {SubPanelSettings} attr Settings for the SubPanel; only &#x60;origin&#x60;, &#x60;consumeOrigin&#x60; and &#x60;target&#x60; are required here
        */
        function captureSubPanel(attr) {
            var subPanel;

            if (attr.consumeOrigin === attr.origin &amp;&amp; subPanels[attr.consumeOrigin]) {
                subPanel = subPanels[attr.origin];
                subPanel.shiftTarget(attr.target);
            } else if (attr.consumeOrigin &amp;&amp; subPanels[attr.consumeOrigin]) {
                subPanel = subPanels[attr.consumeOrigin];
                subPanel.changeOrigin(attr.origin);
                subPanel.shiftTarget(attr.target);

                delete subPanels[attr.consumeOrigin];
                subPanels[attr.origin] = subPanel;
            }
        }

        /**
         * A helper method that fires WMS_QUERY_CHANGE event.
         * 
         * @method wmsQueryPopupHelper
         * @private
         * @param {Object} d deferred to be resolved
         */
        function wmsQueryPopupHelper(d) {
            topic.publish(EventManager.FilterManager.WMS_QUERY_CHANGE, { allowed: RAMP.state.ui.wmsQuery });

            /*jshint validthis: true */
            // I think there is no need to change the label of the button as we are already changing its visual state
            // this is also consistent with how fullscreen and other toolbar buttons work
            /*this.handle
                .children(&#x27;span&#x27;)
                .html(i18n.t(&#x27;gui.actions.wmsQueryEnable&#x27;))
            ;*/

            d.resolve();
        }

        /**
         * Stops event propagation.
         * 
         * @method stopEventPropagation
         * @private
         */
        function stopEventPropagation(event) {
            event.stopPropagation();
        }

        /**
         * A helper function that shows/hides Data tab if there some/none feature layers in the layer selector.
         * 
         * @method autoHideDataTab
         * @private
         */
        function autoHideDataTab() {
            // initialize to the correct state (this might be happening after some layers have already loaded)
            if (RAMP.layerRegistry) {
                var features = Object
                    .keys(RAMP.layerRegistry)
                    .some(function (layer) {
                        return RAMP.layerRegistry[layer].ramp.type === GlobalStorage.layerType.feature;
                    })
                ;

                if (features) {
                    layoutController.toggleDataTab();
                }
            }
            
            // subscribe to Layer added event which is fired every time a layer is added to the map through layer loader
            topic.subscribe(EventManager.LayerLoader.LAYER_ADDED, function (args) {
                if (args.layer.ramp.type === GlobalStorage.layerType.feature) {
                    layoutController.toggleDataTab(true);
                }
            });

            // on each remove check if there are still feature layers in the layer list
            topic.subscribe(EventManager.LayerLoader.REMOVE_LAYER, function () {
                var features = Object.keys(RAMP.layerRegistry).filter(function (layer) {
                    var l = RAMP.layerRegistry[layer];
                    return l ? l.ramp.type === GlobalStorage.layerType.feature : false;
                });
                console.log(&#x27;features left (including the layer to be removed): &#x27; + features.length);
                if (features.length === 1) {
                    layoutController.toggleDataTab();
                }
            });
        }

        return {
            /**
            * Call load to initialize the GUI module.
            *
            * @method load
            * @param  {Number} id   ID of this module
            * @param  {Object} req  dojo required, can be used to require additional modules, etc.
            * @param  {Function} load The callback function to be called as the very last thing in load
            */
            load: function (id, req, load) {
                // measure available space on every page resize

                subPanelTemplate = JSON.parse(TmplHelper.stringifyTemplate(subPanelTemplate));
                subPanelLoadingAnimation = TmplHelper.template(&#x27;loading_simple&#x27;, null, subPanelTemplate);

                layoutController.init();

                // registering help popup
                helpPanelPopup = popupManager.registerPopup(helpToggle, &quot;click&quot;,
                    function (d) {
                        topic.publish(EventManager.GUI.HELP_PANEL_CHANGE, { visible: true });
                        topic.publish(EventManager.GUI.TOOLBAR_SECTION_OPEN, { id: &quot;help-section&quot; });
                        console.log(EventManager.GUI.HELP_PANEL_CHANGE + &quot;; visible:&quot;, true);

                        // close this panel if any other panel is opened
                        UtilMisc.subscribeOnce(EventManager.GUI.TOOLBAR_SECTION_OPEN, dojoLang.hitch(this,
                            function () {
                                if (this.isOpen()) {
                                    this.close();
                                }
                            })
                        );

                        helpSectionContainer.slideToggle(&quot;fast&quot;, function () {
                            d.resolve();
                        });
                    }, {
                        activeClass: cssButtonPressedClass,
                        target: helpSectionContainer,
                        closeHandler: function (d) {
                            topic.publish(EventManager.GUI.HELP_PANEL_CHANGE, { visible: false });
                            topic.publish(EventManager.GUI.TOOLBAR_SECTION_CLOSE, { id: &quot;help-section&quot; });
                            console.log(EventManager.GUI.HELP_PANEL_CHANGE + &quot;; visible:&quot;, false);

                            helpSectionContainer.slideToggle(&quot;fast&quot;, function () {
                                d.resolve();
                            });
                        },
                        resetFocusOnClose: true
                    }
                );

                // WMS query Start
                wmsQueryPopup = popupManager.registerPopup(wmsToggle, &quot;click&quot;,
                    function (d) {
                        RAMP.state.ui.wmsQuery = false;
                        wmsQueryPopupHelper.call(this, d);
                    },
                    {
                        activeClass: cssButtonPressedClass,
                        closeHandler: function (d) {
                            RAMP.state.ui.wmsQuery = true;
                            wmsQueryPopupHelper.call(this, d);
                        }
                    }
                );

                if (RAMP.config.ui.mapQueryToggle.autoHide) {

                    // initialize to the correct state (this might be happening after some layers have already loaded)
                    if (RAMP.layerRegistry) {
                        var wmses = Object.keys(RAMP.layerRegistry).filter(function (layer) { return RAMP.layerRegistry[layer].ramp.type === GlobalStorage.layerType.wms; });
                        if (wmses.length === 0) {
                            wmsToggle.hide();
                        } else {
                            wmsToggle.show();
                        }
                    }

                    // on each load if the layer is a WMS make sure the button is visible
                    topic.subscribe(EventManager.LayerLoader.LAYER_LOADED, function (args) {
                        if (args.layer.ramp.type === GlobalStorage.layerType.wms) {
                            wmsToggle.show();
                        }
                    });

                    // on each remove check if there are still WMSes in the layer list
                    topic.subscribe(EventManager.LayerLoader.REMOVE_LAYER, function () {
                        if (wmsToggle.is(&#x27;:hidden&#x27;)) { return; }
                        var wmses = Object.keys(RAMP.layerRegistry).filter(function (layer) {
                            var l = RAMP.layerRegistry[layer];
                            return l ? l.ramp.type === GlobalStorage.layerType.wms : false;
                        });
                        console.log(&#x27;wmses left (including the layer to be removed): &#x27; + wmses.length);
                        if (wmses.length === 1) {
                            wmsToggle.hide();
                        }
                    });
                }

                // if the query is disabled (from bookmarklink) toggle the button
                if (!RAMP.state.ui.wmsQuery) {
                    wmsQueryPopup.open();
                }
                // WMS query end

                autoHideDataTab();

                //Start AddLayer popup controller
                addLayerPanelPopup = popupManager.registerPopup(addLayerToggle, &quot;click&quot;,
                    function (d) {
                        topic.publish(EventManager.GUI.ADD_LAYER_PANEL_CHANGE, { visible: true });
                        topic.publish(EventManager.GUI.TOOLBAR_SECTION_OPEN, { id: &quot;add-layer-section&quot; });
                        console.log(EventManager.GUI.ADD_LAYER_PANEL_CHANGE + &quot; visible:&quot;, true);

                        // close this panel if any other panel is opened
                        UtilMisc.subscribeOnce(EventManager.GUI.TOOLBAR_SECTION_OPEN, dojoLang.hitch(this,
                            function () {
                                if (this.isOpen()) {
                                    this.close();
                                }
                            })
                        );

                        addLayerSectionContainer.slideToggle(&quot;fast&quot;, function () {
                            d.resolve();
                        });
                    }, {
                        activeClass: cssButtonPressedClass,
                        target: addLayerSectionContainer,
                        closeHandler: function (d) {
                            topic.publish(EventManager.GUI.ADD_LAYER_PANEL_CHANGE, { visible: false });
                            topic.publish(EventManager.GUI.TOOLBAR_SECTION_CLOSE, { id: &quot;add-layer-section&quot; });
                            console.log(EventManager.GUI.ADD_LAYER_PANEL_CHANGE + &quot; visible:&quot;, false);

                            addLayerSectionContainer.slideToggle(&quot;fast&quot;, function () {
                                d.resolve();
                            });
                        },
                        resetFocusOnClose: true
                    }
                );

                $(&quot;#addLayer-add&quot;).on(&quot;click&quot;, function () {
                    topic.publish(EventManager.Map.ADD_LAYER, null);

                    addLayerPanelPopup.close();
                });
                //End Add Layer

                //start extended grid
                topic.subscribe(EventManager.GUI.DATAGRID_EXPAND, function () {
                    layoutController.toggleFullDataMode();
                });
                //end extended grid

                topic.subscribe(EventManager.GUI.TOGGLE_FULLSCREEN, function (evt) {
                    layoutController.toggleFullScreenMode(evt.expand);
                });

                topic.subscribe(EventManager.GUI.SUBPANEL_OPEN, function (attr) {
                    showSubPanel(attr);
                });

                topic.subscribe(EventManager.GUI.SUBPANEL_CLOSE, function (attr) {
                    if (attr.origin === &quot;all&quot;) {
                        utilDict.forEachEntry(subPanels, function (key) {
                            //attr.origin = key;
                            hideSubPanel({
                                origin: key
                            });
                        });
                    } else {
                        dojoArray.forEach(attr.origin.split(&quot;,&quot;), function (element) {
                            //attr.origin = element;
                            hideSubPanel({
                                origin: element
                            });
                        });
                    }
                });

                topic.subscribe(EventManager.GUI.SUBPANEL_DOCK, function (attr) {
                    var na;
                    if (attr.origin === &quot;all&quot;) {
                        utilDict.forEachEntry(subPanels, function (key) {
                            na = Object.create(attr);
                            na.origin = key;
                            dockSubPanel(na);
                        });
                    } else {
                        dojoArray.forEach(attr.origin.split(&quot;,&quot;), function (element) {
                            na = Object.create(attr);
                            na.origin = element;
                            dockSubPanel(na);
                        });
                    }
                    console.log(EventManager.GUI.SUBPANEL_DOCK, attr);
                });

                topic.subscribe(EventManager.GUI.SUBPANEL_CAPTURE, function (attr) {
                    var na;
                    if (attr.consumeOrigin === &quot;all&quot;) {
                        utilDict.forEachEntry(subPanels, function (key) {
                            na = Object.create(attr);
                            na.consumeOrigin = key;
                            captureSubPanel(na);
                        });
                    } else {
                        dojoArray.forEach(attr.consumeOrigin.split(&quot;,&quot;), function (element) {
                            na = Object.create(attr);
                            na.consumeOrigin = element;
                            captureSubPanel(na);
                        });
                    }
                });

                sidePanelTabList.find(&quot;li a&quot;).click(function () {

                    console.log(&quot;inside side panel tab list on click&quot;);
                    var selectedPanelId = $(this).attr(&quot;href&quot;).substr(1);

                    sidePanelTabPanels.find(&quot;details[id=&quot; + selectedPanelId + &quot;]&quot;).each(
                        function () {
                            topic.publish(EventManager.GUI.TAB_SELECTED, {
                                id: this.id,
                                tabName: $(this).data(&quot;panel-name&quot;)
                            });
                        });

                    // the panel currently open is being deselected
                    sidePanelTabPanels.find(&quot;details[aria-expanded=true]&quot;).each(
                        function () {
                            topic.publish(EventManager.GUI.TAB_DESELECTED, {
                                id: this.id,
                                tabName: $(this).data(&quot;panel-name&quot;)
                            });
                        });
                });

                // List of objects containing an event name and an event argument. The events should
                // be anything to wait for before publishing a map extent change, it should include
                // anything that will change the size of the map (e.g. fullscreen, closing the panel).
                // If the map extent change occurs BEFORE something that changes the size of the map (e.g. fullscreen)
                // then the map extent will change again.
                var waitList = [];

                if (!RAMP.state.ui.sidePanelOpened) {
                    // NOTE: panel change not triggered here (see map extent change below)
                    waitList.push({
                        publishName: EventManager.GUI.PANEL_TOGGLE,
                        eventArg: {
                            origin: &quot;bootstrapper&quot;,
                            visible: RAMP.state.ui.sidePanelOpened
                        },
                        subscribeName: EventManager.GUI.PANEL_CHANGE
                    });
                }

                if (RAMP.state.ui.fullscreen) {
                    // NOTE: fullscreen not triggered here (see map extent change below)
                    waitList.push({
                        publishName: EventManager.GUI.TOGGLE_FULLSCREEN,
                        eventArg: {
                            expand: true
                        },
                        subscribeName: EventManager.GUI.FULLSCREEN_CHANGE
                    });
                }

                // return the callback
                load();

                // This should be the last thing that happens
                if (waitList.isEmpty()) {
                    topic.publish(EventManager.GUI.UPDATE_COMPLETE);
                } else {
                    // Wait for things such as fullscreen or panel collapse
                    // to finish before publishing the UPDATE_COMPLETE.

                    // Note it&#x27;s important to subscribe to the events, then
                    // publish them, that&#x27;s why it was done in such an obscure way
                    // using the waitList (otherwise if we just publish the
                    // event like above, then subscribe to it here, the event
                    // might have completed before reaching this point)
                    var eventNames = dojoArray.map(waitList, function (obj) {
                        return obj.subscribeName;
                    });

                    UtilMisc.subscribeAll(eventNames, function () {
                        topic.publish(EventManager.GUI.UPDATE_COMPLETE);
                    });

                    dojoArray.forEach(waitList, function (obj) {
                        topic.publish(obj.publishName, obj.eventArg);
                    });
                }
            }
        };
    }
);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
